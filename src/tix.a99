*********************************************************************
*
* Tix (Qix port)
* For the TI-99/4A home computer
* 16K cartridge version
*
* September 2019
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base
namet1 equ  >2800                      ; Name table base A
namet2 equ  >2c00                      ; Name table base B
spratb equ  >3000                      ; Sprite attribute table base

**
* Constants
*
map_width:
       equ  32
map_width_pixels:
       equ  map_width*8
map_height:
       equ  40
map_height_pixels:
       equ  map_height*8
black:
       equ  0
white:
       equ  1
blue:
       equ  2
red:
       equ  3
tix:
       equ  >ff
tix_tail_size:
       equ  128
top_height:
       equ  24
middle_y:
       equ  (192-top_height)/2
sprite_patters:
       equ  16
char_patterns:
       equ  4
font_patterns:
       equ  96
flood_fill_stack_size:
       equ  512
chr_zero:
       equ  144
chr_zero_tall:
       equ  204

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>20                  ; Start of pad variables

**
* PAD variables
*
frame:
       equ  padvar+2
score:
       equ  frame+2
old_score:
       equ  score+2
y:
       equ  old_score+2
x:
       equ  y+2
dy:
       equ  x+2
dx:
       equ  dy+2
old_dy:
       equ  dx+2
old_dx:
       equ  old_dy+2
fire:
       equ  old_dx+2
slow:
       equ  fire+2
char_aligned:
       equ  slow+2
trail_pointer:
       equ  char_aligned+2
inactivity_time:
       equ  trail_pointer+2
scroll_y:
       equ  inactivity_time+2
name_table_flag:
       equ  scroll_y+2
vdp_status:
       equ  name_table_flag+2
tix_x:                                 ; FP 12.4
       equ  vdp_status+2
tix_y:                                 ; FP 12.4
       equ  tix_x+2
tix_dx:                                ; FP 8.8
       equ  tix_y+2
tix_dy:                                ; FP 8.8
       equ  tix_dx+2
tix_ax:                                ; FP 8.8
       equ  tix_dy+2
tix_ay:                                ; FP 8.8
       equ  tix_ax+2
tix_tail_pointer:
       equ  tix_ay+2
tix_addr:
       equ  tix_tail_pointer+2
tix_char:
       equ  tix_addr+2
spark_1_y:
       equ  tix_char+2
spark_1_x:
       equ  spark_1_y+2
spark_1_dy:
       equ  spark_1_x+2
spark_1_dx:
       equ  spark_1_dy+2
spark_2_y:
       equ  spark_1_dx+2
spark_2_x:
       equ  spark_2_y+2
spark_2_dy:
       equ  spark_2_x+2
spark_2_dx:
       equ  spark_2_dy+2
fuse_y:
       equ  spark_2_dx+2
fuse_x:
       equ  fuse_y+2
fuse_dy:
       equ  fuse_x+2
fuse_dx:
       equ  fuse_dy+2
fuse_trail_pointer:
       equ  fuse_dx+2
fuse_active:
       equ  fuse_trail_pointer+2
upload_map_pad:
       equ  fuse_active+2
buffer:
       equ  upload_map_pad+18
pad_max:
       equ  buffer+8

**
* Macros
*
       .defm proc
       mov  r11,*r10+
       .endm

       .defm endproc
       dect r10
       mov  *r10,r11
       b    *r11
       .endm

       .defm push
       mov  #1,*r10+
       .endm

       .defm pop
       dect r10
       mov  *r10,#1
       .endm

       .defm peek
       mov  @-2(r10),#1
       .endm

***************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       li   r15,vdpwd
       bl   @graphics_mode
       bl   @one_time_init
       bl   @init_game
loop:
       bl   @vsync
       bl   @update_vdp_regs
       bl   @user_input
       bl   @move_player
       bl   @plot_trail
       bl   @move_tix
       bl   @update_sparks
       bl   @update_fuse
       bl   @upload_sprites
       bl   @upload_map
       bl   @display_score
       inc  @frame
       jmp  loop

*********************************************************************
*
* Init game
*
init_game:
       .proc
       clr  @frame
       clr  @score
       seto @old_score
       clr  @scroll_y
       clr  @name_table_flag
       clr  @trail_pointer
       clr  @fuse_trail_pointer
       clr  @fuse_active
       clr  @inactivity_time
       li   r0,tix_tail
       mov  r0,@tix_tail_pointer
       bl   @init_map
*      Player
       li   r0,132
       mov  r0,@x
       li   r0,4
       mov  r0,@y
*      Tix
       clr  @tix_ax
       clr  @tix_ay
       li   r0,1*256
       mov  r0,@tix_dx
       li   r1,-1*256
       mov  r1,@tix_dy
       li   r2,tix_tail_size/4
       li   r3,tix_tail
       li   r4,132*16
       mov  r4,@tix_x
       li   r5,132*16
       mov  r5,@tix_y
init_game_1:
       mov  r5,*r3+
       mov  r4,*r3+
       dec  r2
       jne init_game_1
*      Top panel
       li   r0,namet1
       li   r1,top
       li   r2,top_height/8*32
       bl   @vmbw
       li   r0,namet2
       li   r1,top
       li   r2,top_height/8*32
       bl   @vmbw
*      Sparks
       li   r0,spark_init
       li   r1,spark_1_y
       li   r2,16
       bl   @copy
       .endproc
spark_init:
       data 76,4,-1,0,76,252,1,0
*// init_game

*********************************************************************
*
* Init map
*
init_map:
       li   r0,white*256
*      Top
       li   r1,map
       li   r2,map_width
init_map_1:
       movb r0,*r1+
       dec  r2
       jne  init_map_1
*      Bottom
       li   r1,map+((map_height-1)*map_width)
       li   r2,map_width
init_map_2:
       movb r0,*r1+
       dec  r2
       jne  init_map_2
*      Left
       li   r1,map
       li   r2,map_height
init_map_3:
       movb r0,*r1
       ai   r1,map_width
       dec  r2
       jne  init_map_3
*      Right
       li   r1,map+(map_width-1)
       li   r2,map_height
init_map_4:
       movb r0,*r1
       ai   r1,map_width
       dec  r2
       jne  init_map_4
       rt
*// init_map

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,@vdp_status
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,@vdp_status
       rt
*// vsync

***************************************************************
*
* Update VDP registers
*
update_vdp_regs:
       .proc
*      Set name table
       mov  @name_table_flag,r0
       andi r0,>0001
       ori  r0,>020a
       bl   @vwtr
       inv  @name_table_flag
       .endproc
*// update_vdp_regs

*********************************************************************
*
* Read user input
*
user_input:
       .proc
       clr  @fire
       clr  @char_aligned
       mov  @x,r0
       andi r0,7
       ci   r0,4
       jne  user_input_7
       mov  @y,r1
       andi r1,7
       ci   r1,4
       jne  user_input_7
       seto @char_aligned
       clr  r2
       clr  r3
       li   r0,JOY_FI
       bl   @check_key
*      Fire
       jeq  user_input_1
       seto @fire
       clr  @slow
user_input_1:
*      Left
       tb   1
       jeq  user_input_2
       li   r2,-1
       jmp  user_input_5
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       li   r2,1
       jmp  user_input_5
user_input_3:
*      Down
       tb   3
       jeq  user_input_4
       li   r3,1
       jmp  user_input_5
user_input_4:
*      Up
       tb   4
       jeq  user_input_5
       li   r3,-1
user_input_5:
       abs  @fire
       jeq  user_input_6
       sla  r2,1
       sla  r3,1
user_input_6:
       mov  @dx,@old_dx
       mov  @dy,@old_dy
       mov  r2,@dx
       mov  r3,@dy
user_input_7:
       mov  r2,r0
       jne  user_input_8
       mov  r3,r0
       jne  user_input_8
       inc  @inactivity_time
       jmp  user_input_9
user_input_8:
       clr  @inactivity_time
user_input_9:
       .endproc
*// user_input

*********************************************************************
*
* Move player
*
move_player:
       .proc
*      Check where we're going
       abs  @char_aligned
       jeq  move_player_7
*      Check one char away
       mov  @dx,r0
       mov  @dy,r1
       abs  @slow
       jeq  move_player_1
       sla  r0,3
       sla  r1,3
       jmp  move_player_2
move_player_1:
       sla  r0,2
       sla  r1,2
move_player_2:
       mov  r0,r2
       mov  r1,r3
       a    @x,r0
       a    @y,r1
       bl   @map_address
       movb *r0,r1
       jeq  move_player_4
       cb   r1,@b_white
       jne  move_player_6
       mov  @trail_pointer,r1
       jeq  move_player_7
move_player_3:
       dect r1
       c    r0,*r1
       jeq  move_player_6
       ci   r1,trail
       jne  move_player_3
*      Check two chars away
move_player_4:
       mov  r2,r0
       sla  r0,1
       a    @x,r0
       mov  r3,r1
       sla  r1,1
       a    @y,r1
       bl   @map_address
       cb   *r0,@b_white
       jne  move_player_7
       mov  @trail_pointer,r1
       jeq  move_player_7
move_player_5:
       dect r1
       c    r0,*r1
       jeq  move_player_6
       ci   r1,trail
       jne  move_player_5
       jmp  move_player_7
move_player_6:
       clr  @dx
       clr  @dy
       jmp  move_player_13
*      Move x
move_player_7:
       mov  @x,r0
       a    @dx,r0
       ci   r0,4
       jlt  move_player_8
       ci   r0,256-4
       jgt  move_player_8
       mov  r0,@x
*      Move y
move_player_8:
       mov  @y,r0
       a    @dy,r0
       ci   r0,4
       jlt  move_player_9
       ci   r0,map_height_pixels-4
       jgt  move_player_9
       mov  r0,@y
*      Scroll
move_player_9:
       mov  @y,r0
       ci   r0,middle_y
       jhe  move_player_10
       clr  r0
       jmp  move_player_12
move_player_10:
       ci   r0,map_height_pixels-middle_y
       jlt  move_player_11
       li   r0,map_height_pixels-(192-top_height)
       jmp  move_player_12
move_player_11:
       mov  @y,r0
       ai   r0,-middle_y
move_player_12:
       mov  r0,@scroll_y
move_player_13:
       .endproc
*// move_player

*********************************************************************
*
* Plot trail
*
plot_trail:
       .proc
       abs  @char_aligned
       jeq  plot_trail_2
       mov  @x,r0
       mov  @y,r1
       bl   @map_address
       movb *r0,r1
       jne  plot_trail_1
*      Empty position
       mov  @trail_pointer,r1
       jne  plot_trail_0
       li   r1,trail                   ; New trail
       seto @slow
plot_trail_0:
       mov  r0,*r1+
       mov  r1,@trail_pointer
       li   r2,>0100
       movb r2,*r0                     ; Plot
       jmp  plot_trail_2
*      Not empty position
plot_trail_1:
       mov  @trail_pointer,r1
       jeq  plot_trail_2               ; No trail
       dect r1
       c    r0,*r1
       jeq  plot_trail_2
*      End of trail:
       bl   @fill_closure
       clr  @trail_pointer
       clr  @fuse_trail_pointer
       clr  @fuse_active
plot_trail_2:
       .endproc
*// plot_trail

*********************************************************************
*
* Move Tix
*
move_tix:
       .proc
*      Move towards player
       mov  @trail_pointer,r0
       jeq  move_tix_5
       mov  @x,r0
       sla  r0,4
       s    @tix_x,r0
       sra  r0,6
       mov  r0,@tix_ax
       mov  @y,r1
       sla  r1,4
       s    @tix_y,r1
       sra  r1,6
       mov  r1,@tix_ay
       jmp  move_tix_0
move_tix_5:
       clr  @tix_ax
       clr  @tix_ay
       mov  @tix_dx,r0
       abs  r0
       ci   r0,>0200
       jlt  move_tix_6
       mov  @tix_dx,r0
       sra  r0,1
       mov  r0,@tix_dx
move_tix_6:
       mov  @tix_dy,r1
       abs  r1
       ci   r1,>0200
       jlt  move_tix_0
       mov  @tix_dy,r1
       sra  r1,1
       mov  r1,@tix_dy
*      Acceleration
move_tix_0:
       a    @tix_ax,@tix_dx            ; dx FP 8.8
       a    @tix_ay,@tix_dy            ; dy FP 8.8
*      Velocity
       mov  @tix_dx,r2
       sra  r2,4
       a    @tix_x,r2                  ; Moved x FP 12.4
       mov  @tix_dy,r3
       sra  r3,4
       a    @tix_y,r3                  ; Moved y FP 12.4
*      Position
       mov  r2,r4
       sra  r4,4                       ; Moved x
       mov  r3,r5
       sra  r5,4                       ; Moved y
*      Check moved position for collision
       mov  r4,r0                      ; Moved x
       mov  @tix_y,r1
       sra  r1,4                       ; Unmoved y
       bl   @map_address
       movb *r0,r1
       jeq  move_tix_1
*      Collision vertical
       neg  @tix_dx
       jmp  move_tix_3
move_tix_1:
       mov  @tix_x,r0
       sra  r0,4                       ; Unmoved x
       mov  r5,r1                      ; Moved y
       bl   @map_address
       movb *r0,r1
       jeq  move_tix_2
*      Collision horizontal
       neg  @tix_dy
       jmp  move_tix_3
*      Move
move_tix_2:
       mov  r2,@tix_x
       mov  r3,@tix_y
move_tix_3:
*      Save current position in the tail list
       mov  @tix_tail_pointer,r0
       ai   r0,-4
       ci   r0,tix_tail
       jhe  move_tix_4
       li   r0,tix_tail+tix_tail_size-4
move_tix_4:
       mov  r0,@tix_tail_pointer
       mov  r5,*r0+                    ; y
       mov  r4,*r0+                    ; x
       .endproc
*// move_tix

*********************************************************************
*
* Update sparks
*
update_sparks:
       .proc
       li   r2,2
       li   r3,spark_1_y               ; Ptr y
       mov  r3,r4                      ; Ptr y
       ai   r4,4                       ; Ptr dy
update_sparks_1:
       mov  r3,r5                      ; Copy ptr y
       mov  r4,r6                      ; Copy ptr dy
*      Check if aligned
       mov  *r3+,r1                    ; y
       andi r1,7
       ci   r1,4
       jne  update_sparks_14
       mov  *r3+,r0                    ; x
       andi r0,7
       ci   r0,4
       jne  update_sparks_14
*      Turn towards player
       li   r12,white*256
update_sparks_2:
       mov  r5,r3                      ; Ptr y
       mov  *r3+,r1                    ; y
       mov  *r3+,r0                    ; x
       bl   @map_address
       mov  r0,r7                      ; Save map address
       mov  r5,r3                      ; Ptr y
       mov  *r4,r1                     ; dy
       jne  update_sparks_7
*      Moving in x, check if we can move up/down
       clr  r0                         ; dx = 0
       mov  @y,r1                      ; Player y
       s    *r3,r1                     ; Player y - y
       jlt  update_sparks_4
*      Try down
       ai   r7,map_width
       cb   *r7,r12
       jne  update_sparks_3
       li   r1,1
       jmp  update_sparks_11a
*      Try up instead
update_sparks_3:
       mov  *r3,r8                     ; y
       ci   r8,5
       jlt  update_sparks_6
       ai   r7,-2*map_width
       cb   *r7,r12
       jne  update_sparks_6
       li   r1,-1
       jmp  update_sparks_11a
*      Try up
update_sparks_4:
       ai   r7,-map_width
       cb   *r7,r12
       jne  update_sparks_5
       li   r1,-1
       jmp  update_sparks_11a
*      Try down instead
update_sparks_5:
       mov  *r3,r8                     ; y
       ci   r8,map_height_pixels-5
       jgt  update_sparks_6
       ai   r7,2*map_width
       cb   *r7,r12
       jne  update_sparks_6
       li   r1,1
       jmp  update_sparks_11a
update_sparks_6:
       clr  r1
       jmp  update_sparks_12
*      Moving in y, check if we can move left/right
update_sparks_7:
       clr  r1                         ; dy = 0
       inct r3
       mov  @x,r0                      ; Player x
       s    *r3,r0                     ; PLayer x - x
       jlt  update_sparks_9
*      Try right
       inc  r7
       cb   *r7,r12
       jne  update_sparks_8
       li   r0,1
       jmp  update_sparks_11a
*      Try left instead
update_sparks_8:
       mov  *r3,r8                     ; x
       ci   r8,5
       jlt  update_sparks_11
       dect r7
       cb   *r7,r12
       jne  update_sparks_11
       li   r0,-1
       jmp  update_sparks_11a
*      Try left
update_sparks_9:
       dec  r7
       cb   *r7,r12
       jne  update_sparks_10
       li   r0,-1
       jmp  update_sparks_11a
*      Try right instead
update_sparks_10:
       mov  *r3,r8                     ; x
       ci   r8,map_width_pixels-5
       jgt  update_sparks_11
       inct r7
       cb   *r7,r12
       jne  update_sparks_11
       li   r0,1
       jmp  update_sparks_11a
update_sparks_11:
       clr  r0
       jmp  update_sparks_12
*      Check that spark is not moving into trail
update_sparks_11a:
       mov  @trail_pointer,r9
       jeq  update_sparks_13
       c    r7,@trail
       jne  update_sparks_13
*      Check if it's OK to continue moving
update_sparks_12:
       mov  r5,r3                      ; Ptr y
       mov  r6,r4                      ; Ptr dy
       mov  *r4+,r1                    ; dy
       sla  r1,3                       ; dy * 8
       a    *r3+,r1                    ; dy * 8 + y
       mov  *r4+,r0                    ; dx
       sla  r0,3                       ; dx * 8
       a    *r3+,r0                    ; dx * 8 + x
       bl   @map_address
       cb   *r0,@b_white
       jeq  update_sparks_14            ; Move
       clr  r0
       clr  r1
*      Save dy and dx
update_sparks_13:
       mov  r6,r4
       mov  r1,*r4+                    ; Save dy
       mov  r0,*r4+                    ; Save dx
*      Move
update_sparks_14:
       mov  r5,r3
       mov  r6,r4
       a    *r4+,*r3+                  ; y = y + dy
       a    *r4+,*r3+                  ; x = x + dx
*      Check if player is captured
       mov  r5,r3
       c    *r3+,@y
       jne  update_sparks_15
       c    *r3+,@x
       jne  update_sparks_15
*      Captured
       li   r0,spark_init
       mov  r5,r3
       mov  *r0+,*r3+
       mov  *r0+,*r3+
       mov  *r0+,*r3+
       mov  *r0+,*r3+
*      Loop
update_sparks_15:
       mov  r5,r3
       ai   r3,8
       ai   r4,4
       dec  r2
       jeq  update_sparks_16
       b    @update_sparks_1
update_sparks_16:
       .endproc
*// update_sparks

*********************************************************************
*
* Update fuse
*
update_fuse:
       .proc
       mov  @trail_pointer,r0
       jeq  update_fuse_6
       abs  @fuse_active
       jne  update_fuse_2
       mov  @inactivity_time,r0
       ci   r0,60
       jlt  update_fuse_6
*      Start/restart fuse
       mov  @fuse_trail_pointer,r4
       jne  update_fuse_1
*      Start fuse
       li   r4,trail
       mov  *r4+,r0
       mov  r4,@fuse_trail_pointer
       bl   @map_coords
       mov  r0,@fuse_x
       mov  r1,@fuse_y
*      Restart fuse
update_fuse_1:
       seto @fuse_active
       jmp  update_fuse_4
*      Fuse active
update_fuse_2:
       mov  @inactivity_time,r0
       jeq  update_fuse_3
       mov  @fuse_trail_pointer,r4
       jmp  update_fuse_4
*      Deactivate fuse
update_fuse_3:
       clr  @fuse_active
       jmp  update_fuse_6
*      Check if aligned
update_fuse_4:
       mov  @fuse_x,r0
       andi r0,7
       ci   r0,4
       jne  update_fuse_5
       mov  @fuse_y,r1
       andi r1,7
       ci   r1,4
       jne  update_fuse_5
*      Set new direction
       mov  *r4+,r0
       mov  r4,@fuse_trail_pointer
       bl   @map_coords
       s    @fuse_x,r0
       sra  r0,3
       mov  r0,@fuse_dx
       s    @fuse_y,r1
       sra  r1,3
       mov  r1,@fuse_dy
update_fuse_5:
*      Move fuse
       a    @fuse_dx,@fuse_x
       a    @fuse_dy,@fuse_y
*      Check if player is captured
       c    @fuse_x,@x
       jne  update_fuse_6
       c    @fuse_y,@y
       jne  update_fuse_6
*      Stop fuse
       clr  @fuse_active
       clr  @fuse_trail_pointer
update_fuse_6:
       .endproc
*// update_fuse

*********************************************************************
*
* Upload sprites
*
upload_sprites:
       .proc
       li   r0,spratb
       bl   @vwad
*      Player
       li   r3,y
       li   r4,>000d
       bl   @upload_sprite
*      Tix
       li   r2,4
       mov  @tix_tail_pointer,r3
       li   r4,tix_attr
upload_sprites_1:
       mov  *r3+,r1
       s    @scroll_y,r1
       jlt  upload_sprites_2
       ai   r1,top_height-9
       ci   r1,191
       jgt  upload_sprites_2
       swpb r1
       movb r1,*r15
       mov  *r3+,r1
       ai   r1,-8
       swpb r1
       movb r1,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       jmp  upload_sprites_3
upload_sprites_2:
       inct r3
       inct r4
upload_sprites_3:
       ai   r3,8
       ci   r3,tix_tail+tix_tail_size
       jl   upload_sprites_4
       ai   r3,-tix_tail_size
upload_sprites_4:
       dec  r2
       jne  upload_sprites_1
*      Sparks
       li   r3,spark_1_y
       li   r4,>200b
       li   r5,2
upload_sprites_5:
       bl   @upload_sprite
       ai   r3,4
       dec  r5
       jne  upload_sprites_5
*      Fuse
       abs  @fuse_active
       jeq  upload_sprites_6
       li   r3,fuse_y
       li   r4,>3008
       bl   @upload_sprite
*      End marker
upload_sprites_6:
       movb @b_d0,*r15
       .endproc
tix_attr:
       data >100c,>1402,>1803,>1C0e
*// upload_sprites

*********************************************************************
*
* Upload sprite
*
* r3: points to y
* r4: contains base pattern and color
*
upload_sprite:
       mov  *r3+,r1                    ; y
       s    @scroll_y,r1
       jlt  upload_sprite_2
       ci   r1,(192-top_height)+8
       jhe  upload_sprite_2
       ai   r1,top_height-9
       swpb r1
       movb r1,*r15
       mov  r4,r2                      ; Pattern and color
       mov  *r3+,r1                    ; x
       ai   r1,-8
       jgt  upload_sprite_1
       ai   r1,32                      ; EC
       ori  r2,>0080
upload_sprite_1:
       swpb r1
       mov  r1,*r15
       mov  @frame,r1                  ; Animation frame
       andi r1,>000c
       swpb r1                         ; Pattern
       soc  r2,r1
       movb r1,*r15
       swpb r1                         ; Color
       mov  r1,*r15
       jmp  upload_sprite_3
upload_sprite_2:
       inct r3
upload_sprite_3:
       rt
*// upload_sprite

*********************************************************************
*
* Upload one screen of map to VDP
*
upload_map:
       .proc
       mov  @name_table_flag,r0
       andi r0,>0001
       sla  r0,10
       ai   r0,namet1+(32*top_height/8)
       bl   @vwad
       li   r0,map
       li   r1,map+32
       li   r2,32*(192-top_height)/8
       clr  r3
       mov  @scroll_y,r5
       dec  r5
       srl  r5,3
       sla  r5,5
       a    r5,r0
       a    r5,r1
       mov  @scroll_y,r5
       dec  r5
       andi r5,7
       sla  r5,4
       movb @r5lb,r5
       li   r6,r3lb
       bl   @upload_map_pad
       .endproc
upload_map_1:
       mov  *r1+,r3                    ; Get 2 bytes from row 1
       sla  r3,2                       ; Shift up
       soc  *r0+,r3                    ; Combine with two bytes from row 2
       a    r5,r3                      ; Add scroll offset
       movb r3,*r15                     ; Send one byte to VDP
       movb *r6,*r15                    ; Send the other byte to VDP
       dect r2                         ; Counter
       jne  upload_map_1               ; Loop
       rt
upload_map_2
*// upload_map

*********************************************************************
*
* Fill closure
*
fill_closure:
       .proc
       bl   @save_map
       abs  @slow
       jne  fill_closure_1
       li   r9,blue*256
       jmp  fill_closure_2
fill_closure_1:
       li   r9,red*256
fill_closure_2:
*      Fill to the right
       mov  @x,r0
       mov  @y,r1
       mov  @old_dx,r2
       mov  @old_dy,r3
       sla  r2,3
       sla  r3,3
       s    r2,r0                      ; Backtrack one tile
       s    r3,r1
       s    r3,r0                      ; One tile to the right
       a    r2,r1
       mov  r9,r2
       li   r3,white*256
       bl   @flood_fill
       mov  r4,r4
       jgt  fill_closure_3
       jeq  fill_closure_3
*      Fill to the left
       bl   @restore_map
       mov  @x,r0
       mov  @y,r1
       mov  @old_dx,r2
       sla  r2,3
       mov  @old_dy,r3
       sla  r3,3
       s    r2,r0                      ; Backtrack one tile
       s    r3,r1
       a    r3,r0                      ; One tile to the left
       s    r2,r1
       mov  r9,r2
       li   r3,white*256
       bl   @flood_fill
fill_closure_3:
       abs  @slow
       jeq  fill_closure_4
       sla  r4,1
fill_closure_4:
       a    r4,@score
       .endproc
*// fill_closure

*********************************************************************
*
* Save map
*
save_map:
       .proc
       li   r0,map
       li   r1,map_backup
       li   r2,map_width*map_height
       bl   @copy
       .endproc
*// save_map

*********************************************************************
*
* Restore map
*
restore_map:
       .proc
       li   r0,map_backup
       li   r1,map
       li   r2,map_width*map_height
       bl   @copy
       .endproc
*// restore_map

*********************************************************************
*
* Get char
*
* r0: x (pixels)
* r1: y (pixels)
*
* On return r1 MSB contains the char and r0 contains the address.
*
get_char:
       .proc
       bl   @map_address
       movb *r0,r1
       .endproc
*// get_char

*********************************************************************
*
* Plot
*
* r0: x (pixels)
* r1: y (pixels)
* r2: char (MSB)
*
* On r0 contains the address. r1 is modified. r2 is preserved.
*
plot:
       .proc
       bl   @map_address
       movb r2,*r0
       .endproc
*// plot

*********************************************************************
*
* Flood fill
*
* r0: x (pixels)
* r1: y (pixels)
* r2 (MSB): replacement char
* r3 (MSB): target char
*
* On return r4 contains the number of pixels filled.
*
flood_fill:
       .proc
       bl   @mark_tix
       bl   @map_address
       bl   @flood_fill_addr
       bl   @unmark_tix
       .endproc
*// flood_fill

*********************************************************************
*
* Flood fill address
*
* r0: map address to fill from
* r2 (MSB): replacement char
* r3 (MSB): target char
*
* On return r4 contains the number of pixels filled.
*
flood_fill_addr:
       li   r1,flood_fill_stack
       mov  r0,*r1+
       clr  r4                         ; Counter
flood_fill_addr_1:
       dect r1
       mov  *r1,r0                     ; Pop address
       movb *r0,r5                     ; Get existing char
       jlt  flood_fill_addr_3          ; Tix found
       cb   r2,r5                      ; Compare to fill char
       jeq  flood_fill_addr_2          ; Stop if filled
       cb   r3,r5                      ; Compare to target char
       jeq  flood_fill_addr_2          ; Stop if filled
       movb r2,*r0+                    ; Fill and move right
       mov  r0,*r1+                    ; Push right
       dect r0                         ; Move left
       mov  r0,*r1+                    ; Push left
       ai   r0,map_width+1             ; Move down
       mov  r0,*r1+                    ; Push down
       ai   r0,-map_width*2            ; Move up
       mov  r0,*r1+                    ; Push up
       inc  r4
       jmp  flood_fill_addr_1
flood_fill_addr_2:
       ci   r1,flood_fill_stack        ; Is stack empty?
       jne  flood_fill_addr_1          ; No - loop
       jmp  flood_fill_addr_4
flood_fill_addr_3:
       seto r4                         ; Tix found
flood_fill_addr_4:
       rt
*// flood_fill_addr

*********************************************************************
*
* Mark tix on map
*
mark_tix:
       .proc
       .push r0
       .push r1
       mov  @tix_x,r0
       srl  r0,4
       mov  @tix_y,r1
       srl  r1,4
       bl   @get_char
       mov  r0,@tix_addr
       movb r1,@tix_char
       movb @b_tix,*r0
       .pop r1
       .pop r0
       .endproc
*// mark_tix

*********************************************************************
*
* Unmark tix on map
*
unmark_tix:
       mov  @tix_addr,r0
       movb @tix_char,*r0
       rt
*// unmark_tix

*********************************************************************
*
* Map address from coordinates
*
* r0: x (pixels)
* r1: y (pixels)
*
* On return r0 contains the address. r1 is modified.
*
map_address:
       sra  r1,3                       ; y / 8
       sla  r1,5                       ; * 32
       srl  r0,3                       ; x / 8
       a    r1,r0                      ; (x / 8) + (y / 8) * 32
       ai   r0,map
       rt
*// map_address

*********************************************************************
*
* Map coordinates from address
*
* r0: address
*
* On return r0 contains the x coord and r1 contains the y coord
* of the center of the tile.
*
map_coords:
       ai   r0,-map                    ; Offset
       mov  r0,r1                      ; copy offset
       andi r0,31                      ; x = offset mod 32
       sla  r0,3                       ; * 8
       ai   r0,4                       ; + 4
       srl  r1,5                       ; y = offset / 32
       sla  r1,3                       ; * 8
       ai   r1,4                       , + 4
       rt
*// map_coords

*********************************************************************
*
* Display score
*
display_score:
       .proc
       c    @score,@old_score
       jeq  display_score_1
       li   r0,26
       mov  @score,r1
       li   r2,5
       bl   @display_tall_decimal
       mov  @score,@old_score
display_score_1:
       .endproc
*// display_score

*********************************************************************
*
* Display double height number
*
* r0: Screen offset
* r1: Number to display
* r2: Number of digits
*
display_tall_decimal:
       .proc
       mov  r0,r5
       mov  r2,r6
       bl   @bin_to_dec
       ai   r5,namet1
       li   r7,2
display_tall_decimal_1:
*      1st name table buffer, 1st row
       mov  r5,r0
       li   r1,buffer
       mov  r6,r2
       li   r3,(chr_zero_tall-chr_zero)*256
       bl   @vmbw_offs
*      1st name table buffer, 2nd row
       mov  r5,r0
       ai   r0,32
       li   r1,buffer
       mov  r6,r2
       li   r3,(chr_zero_tall+10-chr_zero)*256
       bl   @vmbw_offs
*      Next buffer
       ai   r5,namet2-namet1
       dec  r7
       jne  display_tall_decimal_1
       .endproc
*// display_tall_decimal

*********************************************************************
*
* Display decimal number
*
* r0: Screen offset
* r1: Number to display
* r2: Number of digits
*
display_decimal:
       .proc
       mov  r0,r5
       mov  r2,r6
       bl   @bin_to_dec
*      1st name table buffer
       mov  r5,r0
       ai   r0,namet1
       li   r1,buffer
       mov  r6,r2
       bl   @vmbw
*      2nd name table buffer
       mov  r5,r0
       ai   r0,namet2
       li   r1,buffer
       mov  r6,r2
       bl   @vmbw
       .endproc
*// display_decimal

*********************************************************************
*
* Convert binary number to decimal
*
* r1: Number to display
* r2: Number of digits
*
* On return @buffer contains the number
*
bin_to_dec:
       li   r4,buffer
       li   r3,5
       s    r2,r3
       sla  r3,1
       ai   r3,d10000
       dec  r2
bin_to_dec_1:
       clr  r0
       div  *r3+,r0
       ai   r0,chr_zero
       swpb r0
       movb r0,*r4+
       dec  r2
       jne  bin_to_dec_1
       ai   r1,chr_zero
       swpb r1
       movb r1,*r4+
       rt
d10000:
       data 10000
d1000:
       data 1000
d100:
       data 100
d10:
       data 10
*// bin_to_dec

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
*      Patterns
       li   r0,ptrntb
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
       li   r0,ptrntb+>800
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
       li   r0,ptrntb+>1000
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
*      Colors
       li   r0,colrtb
       li   r1,colors
       li   r2,8*8*16
       bl   @vmbw
*      Font
       li   r0,ptrntb+>400
       li   r1,PAT128
       li   r2,font_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>c00
       li   r1,PAT128
       li   r2,font_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>1400
       li   r1,PAT128
       li   r2,font_patterns*8
       bl   @vmbw
*      Font colors
       li   r0,colrtb+>400
       li   r1,COL128
       li   r2,font_patterns*8
       bl   @vmbw
*      Sprite patterns
       li   r0,sprptb
       li   r1,SPR0
       li   r2,sprite_patters*32
       bl   @vmbw
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Copy code to PAD
       li   r0,upload_map_1
       li   r1,upload_map_pad
       li   r2,upload_map_2-upload_map_1
one_time_init_1:
       mov  *r0+,*r1+
       dect r2
       jne  one_time_init_1
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte namet1/>400                ; Name table
       byte >9f                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       rt
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       rt
*// vwad

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,*r15                    ; Write byte to VDP RAM
       rt
*// vsbw

*********************************************************************
*
* VDP multiple Byte Write
*
* R0: Write address in VDP RAM
* R1: Starting read address in CPU RAM
* R2: Number of bytes to send
*
vmbw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbw_1:
       movb *r1+,*r15                  ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_1
       rt
*// vmbw

*********************************************************************
*
* VDP multiple Byte Write with offset
*
* R0: Write address in VDP RAM
* R1: Starting read address in CPU RAM
* R2: Number of bytes to send
* R3: Offset to add to bytes
*
vmbw_offs:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbw_offs_1:
       movb *r1+,r4
       ab   r3,r4
       movb r4,*r15                    ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_offs_1
       rt
*// vmbw_offs

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
* R2: Number of bytes to write to VDP RAM
*
vsmw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vsmw_1:
       movb r1,*r15                    ; Write byte to VDP RAM
       dec  r2                         ; Byte counter
       jne  vsmw_1
       rt
*// vsmw

*********************************************************************
*
* VDP Set Read Address
*
* R0: Read address in VDP RAM
*
vrad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       rt
*// vrad

*********************************************************************
*
* VDP Single Byte Read
*
* R0:  Read address in VDP RAM
* R1:  MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       nop
       movb @vdprd,r1                  ; Read byte from VDP RAM
       rt
*// vsbr

*********************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM read address
       andi r0,>3fff                   ; Set read/write bits 14 and 15 to read (00)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       li   r0,vdprd
vmbr_1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr_1                     ; Check if finished
       rt
*// vmbr

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source
* r1: destination
* r2: number of bytes
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* Data
*
b_black:
       byte black
b_white:
       byte white
b_blue:
       byte blue
b_red:
       byte red
b_tix:
       byte tix
b_d0:
       byte >d0

       copy "chars.a99"
       copy "sprites.a99"
       copy "font.a99"
       copy "top.a99"

* One extra map row to support scrolling
       DATA >0303,>0303,>0303,>0303    ;
       DATA >0303,>0303,>0303,>0303    ;
       DATA >0303,>0303,>0303,>0303    ;
       DATA >0303,>0303,>0303,>0303    ;
map:
       bss  map_width*map_height
* One extra map row to support scrolling
       DATA >0303,>0303,>0303,>0303    ;
       DATA >0303,>0303,>0303,>0303    ;
       DATA >0303,>0303,>0303,>0303    ;
       DATA >0303,>0303,>0303,>0303    ;
map_backup:
       bss  map_width*map_height
tix_tail:
       bss  tix_tail_size
trail:
       equ  $
flood_fill_stack:
       bss  flood_fill_stack_size

       end main
