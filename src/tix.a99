*********************************************************************
*
* Tix (Qix port)
* For the TI-99/4A home computer
* 16K cartridge version
*
* September 2019
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base
namet1 equ  >2800                      ; Name table base A
namet2 equ  >2c00                      ; Name table base B
spratb equ  >3000                      ; Sprite attribute table base

**
* Constants
*
map_width:
       equ  32
map_width_pixels:
       equ  256
map_height:
       equ  64
map_height_pixels:
       equ  512

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>18                  ; Start of pad variables

**
* PAD variables
*
x:
       equ  padvar+2
y:
       equ  x+2
dx:
       equ  y+2
dy:
       equ  dx+2
fire:
       equ  dy+2
scroll_y:
       equ  fire+2
name_table_flag:
       equ  scroll_y+2
vdp_status:
       equ  name_table_flag+2
upload_map_pad:
       equ  vdp_status+2
pad_max:
       equ  upload_map_pad+16

**
* Macros
*
       .defm proc
       mov  r11,*r10+
       .endm

       .defm endproc
       dect r10
       mov  *r10,r11
       b    *r11
       .endm

       .defm push
       mov  #1,*r10+
       .endm

       .defm pop
       dect r10
       mov  *r10,#1
       .endm

       .defm peek
       mov  @-2(r10),#1
       .endm

***************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @graphics_mode
       bl   @one_time_init
       clr  @scroll_y
       clr  @name_table_flag
       li   r0,128
       mov  r0,@x
       li   r0,0
       mov  r0,@y
loop:
       bl   @vsync
       bl   @update_vdp_regs
       bl   @user_input
       bl   @move_player
       bl   @upload_sprites
       bl   @upload_map
       jmp  loop

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,@vdp_status
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,@vdp_status
       rt
*// vsync

***************************************************************
*
* Update VDP registers
*
update_vdp_regs:
       .proc
*      Set name table
       mov  @name_table_flag,r0
       andi r0,>0001
       ori  r0,>020a
       bl   @vwtr
       inv  @name_table_flag
       .endproc
*// update_vdp_regs

*********************************************************************
*
* Read user input
*
user_input:
       .proc
       clr  @fire
       mov  @x,r0
       andi r0,7
       jne  !
       clr  @dx
!      mov  @y,r0
       andi r0,7
       jne  !
       clr  @dy
!      li   r0,JOY_FI
       bl   @check_key
*      Fire
       jeq  user_input_1
       seto @fire
user_input_1:
*      Left
       tb   1
       jeq  user_input_2
       li   r0,-1
       mov  r0,@dx
       jmp  user_input_5
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       li   r0,1
       mov  r0,@dx
       jmp  user_input_5
user_input_3:
*      Down
       tb   3
       jeq  user_input_4
       li   r0,1
       mov  r0,@dy
       jmp  user_input_5
user_input_4:
*      Up
       tb   4
       jeq  user_input_5
       li   r0,-1
       mov  r0,@dy
user_input_5:
       .endproc
*// user_input

*********************************************************************
*
* Move player
*
move_player:
       .proc
*      Move x
       mov  @x,r0
       a    @dx,r0
       ci   r0,0
       jlt  move_player_1
       ci   r0,256-8
       jgt  move_player_1
       mov  r0,@x
*      Move y
move_player_1:
       mov  @y,r0
       a    @dy,r0
       ci   r0,0
       jlt  move_player_2
       ci   r0,map_height_pixels-8
       jgt  move_player_2
       mov  r0,@y
*      Scroll
move_player_2:
       mov  @y,r0
       ci   r0,96
       jhe  move_player_3
       clr  r0
       jmp  move_player_5
move_player_3:
       ci   r0,map_height_pixels-96
       jlt  move_player_4
       li   r0,map_height_pixels-192
       jmp  move_player_5
move_player_4:
       mov  @y,r0
       ai   r0,-96
move_player_5:
       mov  r0,@scroll_y
*      Plot trail
       mov  @y,r0
       ai   r0,4
       mov  @x,r1
       ai   r1,4
       bl   @map_address
       li   r2,>0100
       movb r2,*r0
       .endproc
*// move_player

*********************************************************************
*
* Upload sprites
*
upload_sprites:
       .proc
       li   r0,spratb
       bl   @vwad
       li   r0,vdpwd
       mov  @y,r1
       s    @scroll_y,r1
       dec  r1
       swpb r1
       movb r1,*r0
       mov  @x,r1
       swpb r1
       mov  r1,*r0
       li   r1,>100d
       movb r1,*r0
       swpb r1
       mov  r1,*r0
       li   r1,>0d00
       mov  r1,*r0
       .endproc
*// upload_sprites

*********************************************************************
*
* Upload one screen of map to VDP
*
upload_map:
       .proc
       mov  @name_table_flag,r0
       andi r0,>0001
       sla  r0,10
       ai   r0,namet1
       bl   @vwad
       li   r0,map
       li   r1,map+32
       li   r2,768
       clr  r3
       li   r4,vdpwd
       mov  @scroll_y,r5
       dec  r5
       srl  r5,3
       sla  r5,5
       a    r5,r0
       a    r5,r1
       mov  @scroll_y,r5
       dec  r5
       andi r5,7
       sla  r5,4
       swpb r5
       bl   @upload_map_pad
       .endproc
upload_map_1:
       movb *r1+,r3
       sla  r3,2
       socb *r0+,r3
       ab   r5,r3
       movb r3,*r4
       dec  r2
       jne  upload_map_1
       rt
upload_map_2
*// upload_map

*********************************************************************
*
* Get char
*
* r0: x (pixels)
* r1: y (pixels)
*
get_char:
       .proc
       bl   @map_address
       movb *r0,r1
       .endproc
*// get_char

*********************************************************************
*
* Plot
*
* r0: x (pixels)
* r1: y (pixels)
* r2: char (MSB)
*
plot:
       .proc
       bl   @map_address
       movb r2,*r0
       .endproc
*// plot

*********************************************************************
*
* Map address
*
* r0: x (pixels)
* r1: y (pixels)
*
map_address:
       srl  r0,3
       sla  r0,5
       srl  r1,3
       a    r1,r0
       ai   r0,map
       rt
*// map_address

*********************************************************************
*
* Flood fill
*
* r0: x (pixels)
* r1: y (pixels)
* r2 (MSB): replacement char
* r3 (MSB): target char
*
flood_fill:
       .proc
       srl  r0,3
       sla  r0,5
       srl  r1,3
       a    r1,r0
       ai   r0,map
       li   r1,flood_fill_stack
       mov  r0,*r1+
flood_fill_1:
       dect r1
       mov  *r1,r0                     ; Pop address
       cb   r2,*r0                     ; Compare to fill char
       jeq  flood_fill_2               ; Stop if filled
       cb   r3,*r0                     ; Compare to target char
       jeq  flood_fill_2               ; Stop if filled
       movb r2,*r0+                    ; Fill and move right
       mov  r0,*r1+                    ; Push right
       dect r0                         ; Move left
       mov  r0,*r1+                    ; Push left
       ai   r0,map_width+1             ; Move down
       mov  r0,*r1+                    ; Push down
       ai   r0,-map_width*2            ; Move up
       mov  r0,*r1+                    ; Push up
       jmp  flood_fill_1
flood_fill_2:
       ci   r1,flood_fill_stack        ; Is stack empty?
       jne  flood_fill_1               ; No - loop
       .endproc
*// flood_fill

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r0,ptrntb
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
       li   r0,ptrntb+>800
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
       li   r0,ptrntb+>1000
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
       li   r0,colrtb
       li   r1,colors
       li   r2,8*8*16
       bl   @vmbw
       li   r0,sprptb
       li   r1,SPR0
       li   r2,5*32
       bl   @vmbw
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Copy code to PAD
       li   r0,upload_map_1
       li   r1,upload_map_pad
       li   r2,upload_map_2-upload_map_1
one_time_init_1:
       mov  *r0+,*r1+
       dect r2
       jne  one_time_init_1
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte namet1/>400                ; Name table
       byte >9f                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       rt
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       rt
*// vwad

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,*r15                    ; Write byte to VDP RAM
       rt
*// vsbw

*********************************************************************
*
* VDP multiple Byte Write
*
* R0: Write address in VDP RAM
* R1: Starting read address in CPU RAM
* R2: Number of bytes to send
*
vmbw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
vmbw_1:
       movb *r1+,*r0                   ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_1
       rt
*// vmbw

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
* R2: Number of bytes to write to VDP RAM
*
vsmw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
vsmw_1:
       movb r1,*r0                     ; Write byte to VDP RAM
       dec  r2                         ; Byte counter
       jne  vsmw_1
       rt
*// vsmw

*********************************************************************
*
* VDP Set Read Address
*
* R0: Read address in VDP RAM
*
vrad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       rt
*// vrad

*********************************************************************
*
* VDP Single Byte Read
*
* R0:  Read address in VDP RAM
* R1:  MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       nop
       movb @vdprd,r1                  ; Read byte from VDP RAM
       rt
*// vsbr

*********************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM read address
       andi r0,>3fff                   ; Set read/write bits 14 and 15 to read (00)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       li   r0,vdprd
vmbr_1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr_1                     ; Check if finished
       rt
*// vmbr

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* Data
*
       copy "chars.a99"
       copy "sprites.a99"
       copy "map.a99"

flood_fill_stack:
       bss  2*768

       end main
