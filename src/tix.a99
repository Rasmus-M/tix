*********************************************************************
*
* Tix (Qix port)
* For the TI-99/4A home computer
* 16K cartridge version
*
* September 2019
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base
namet1 equ  >2800                      ; Name table base A
namet2 equ  >2c00                      ; Name table base B
spratb equ  >3000                      ; Sprite attribute table base

**
* Constants
*
map_width:
       equ  32
map_width_pixels:
       equ  256
map_height:
       equ  64
map_height_pixels:
       equ  512
black:
       equ  0
white:
       equ  1
blue:
       equ  2
red:
       equ  3
tix:
       equ  >ff
tix_tail_size:
       equ  128

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>20                  ; Start of pad variables

**
* PAD variables
*
x:
       equ  padvar+2
y:
       equ  x+2
dx:
       equ  y+2
dy:
       equ  dx+2
old_dx:
       equ  dy+2
old_dy:
       equ  old_dx+2
fire:
       equ  old_dy+2
char_aligned:
       equ  fire+2
trail_pointer:
       equ  char_aligned+2
scroll_y:
       equ  trail_pointer+2
name_table_flag:
       equ  scroll_y+2
vdp_status:
       equ  name_table_flag+2
tix_x:                                 ; FP 12.4
       equ  vdp_status+2
tix_y:                                 ; FP 12.4
       equ  tix_x+2
tix_dx:                                ; FP 8.8
       equ  tix_y+2
tix_dy:                                ; FP 8.8
       equ  tix_dx+2
tix_ax:                                ; FP 8.8
       equ  tix_dy+2
tix_ay:                                ; FP 8.8
       equ  tix_ax+2
tix_tail_pointer:
       equ  tix_ay+2
tix_addr:
       equ  tix_tail_pointer+2
tix_char:
       equ  tix_addr+2
upload_map_pad:
       equ  tix_char+2
pad_max:
       equ  upload_map_pad+16

**
* Macros
*
       .defm proc
       mov  r11,*r10+
       .endm

       .defm endproc
       dect r10
       mov  *r10,r11
       b    *r11
       .endm

       .defm push
       mov  #1,*r10+
       .endm

       .defm pop
       dect r10
       mov  *r10,#1
       .endm

       .defm peek
       mov  @-2(r10),#1
       .endm

***************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @graphics_mode
       bl   @one_time_init
       bl   @init_game
loop:
       bl   @vsync
       bl   @update_vdp_regs
       bl   @user_input
       bl   @move_player
       bl   @plot_trail
       bl   @move_tix
       bl   @upload_sprites
       bl   @upload_map
       jmp  loop

*********************************************************************
*
* Init game
*
init_game:
       .proc
       clr  @scroll_y
       clr  @name_table_flag
       clr  @trail_pointer
       li   r0,tix_tail
       mov  r0,@tix_tail_pointer
*      Player
       li   r0,132
       mov  r0,@x
       li   r0,4
       mov  r0,@y
*      Tix
       clr  @tix_ax
       clr  @tix_ay
       li   r0,1*256
       mov  r0,@tix_dx
       li   r1,-1*256
       mov  r1,@tix_dy
       li   r2,tix_tail_size/4
       li   r3,tix_tail
       li   r4,132*16
       mov  r4,@tix_x
       li   r5,132*16
       mov  r5,@tix_y
init_game_1:
       mov  r5,*r3+
       mov  r4,*r3+
       dec  r2
       jne init_game_1
       .endproc
*// init_game

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,@vdp_status
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,@vdp_status
       rt
*// vsync

***************************************************************
*
* Update VDP registers
*
update_vdp_regs:
       .proc
*      Set name table
       mov  @name_table_flag,r0
       andi r0,>0001
       ori  r0,>020a
       bl   @vwtr
       inv  @name_table_flag
       .endproc
*// update_vdp_regs

*********************************************************************
*
* Read user input
*
user_input:
       .proc
       clr  @fire
       clr  @char_aligned
       mov  @x,r0
       andi r0,7
       ci   r0,4
       jne  user_input_5
       mov  @y,r1
       andi r1,7
       ci   r1,4
       jne  user_input_5
       seto @char_aligned
       mov  @dx,@old_dx
       mov  @dy,@old_dy
       clr  @dx
       clr  @dy
       li   r0,JOY_FI
       bl   @check_key
*      Fire
       jeq  user_input_1
       seto @fire
user_input_1:
*      Left
       tb   1
       jeq  user_input_2
       li   r0,-1
       mov  r0,@dx
       jmp  user_input_5
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       li   r0,1
       mov  r0,@dx
       jmp  user_input_5
user_input_3:
*      Down
       tb   3
       jeq  user_input_4
       li   r0,1
       mov  r0,@dy
       jmp  user_input_5
user_input_4:
*      Up
       tb   4
       jeq  user_input_5
       li   r0,-1
       mov  r0,@dy
user_input_5:
       .endproc
*// user_input

*********************************************************************
*
* Move player
*
move_player:
       .proc
*      Check where we're going
       abs  @char_aligned
       jeq  move_player_2
       mov  @dx,r0
       sla  r0,3
       a    @x,r0
       mov  @dy,r1
       sla  r1,3
       a    @y,r1
       bl   @get_char
       movb r1,r1
       jeq  move_player_2
       cb   r1,@b_white
       jne  move_player_1
       mov  @trail_pointer,r1
       jeq  move_player_2
move_player_0:
       dect r1
       c    r0,*r1
       jeq  move_player_1
       ci   r1,trail
       jne  move_player_0
       jmp  move_player_2
move_player_1:
       clr  @dx
       clr  @dy
       jmp  move_player_8
*      Move x
move_player_2:
       mov  @x,r0
       a    @dx,r0
       ci   r0,4
       jlt  move_player_3
       ci   r0,256-4
       jgt  move_player_3
       mov  r0,@x
*      Move y
move_player_3:
       mov  @y,r0
       a    @dy,r0
       ci   r0,4
       jlt  move_player_4
       ci   r0,map_height_pixels-4
       jgt  move_player_4
       mov  r0,@y
*      Scroll
move_player_4:
       mov  @y,r0
       ci   r0,96
       jhe  move_player_5
       clr  r0
       jmp  move_player_7
move_player_5:
       ci   r0,map_height_pixels-96
       jlt  move_player_6
       li   r0,map_height_pixels-192
       jmp  move_player_7
move_player_6:
       mov  @y,r0
       ai   r0,-96
move_player_7:
       mov  r0,@scroll_y
move_player_8:
       .endproc
*// move_player

*********************************************************************
*
* Plot trail
*
plot_trail:
       .proc
       abs  @char_aligned
       jeq  plot_trail_2
       mov  @x,r0
       mov  @y,r1
       bl   @get_char
       movb r1,r1
       jne  plot_trail_1
*      Empty position
       mov  @trail_pointer,r1
       jne  plot_trail_0
       li   r1,trail                   ; New trail
plot_trail_0:
       mov  r0,*r1+
       mov  r1,@trail_pointer
       li   r2,>0100
       movb r2,*r0                     ; Plot
       jmp  plot_trail_2
*      Not empty position
plot_trail_1:
       mov  @trail_pointer,r1
       jeq  plot_trail_2               ; No trail
       dect r1
       c    r0,*r1
       jeq  plot_trail_2
*      End of trail:
       bl   @fill_closure
       clr  @trail_pointer
plot_trail_2:
       .endproc
*// plot_trail

*********************************************************************
*
* Move Tix
*
move_tix:
       .proc
*      Move towards player
       mov  @trail_pointer,r0
       jeq  move_tix_5
       mov  @x,r0
       sla  r0,4
       s    @tix_x,r0
       sra  r0,6
       mov  r0,@tix_ax
       mov  @y,r1
       sla  r1,4
       s    @tix_y,r1
       sra  r1,6
       mov  r1,@tix_ay
       jmp  move_tix_0
move_tix_5:
       clr  @tix_ax
       clr  @tix_ay
       mov  @tix_dx,r0
       abs  r0
       ci   r0,>0200
       jlt  move_tix_6
       mov  @tix_dx,r0
       sra  r0,1
       mov  r0,@tix_dx
move_tix_6:
       mov  @tix_dy,r1
       abs  r1
       ci   r1,>0200
       jlt  move_tix_0
       mov  @tix_dy,r1
       sra  r1,1
       mov  r1,@tix_dy
*      Acceleration
move_tix_0:
       a    @tix_ax,@tix_dx            ; dx FP 8.8
       a    @tix_ay,@tix_dy            ; dy FP 8.8
*      Velocity
       mov  @tix_dx,r2
       sra  r2,4
       a    @tix_x,r2                  ; Moved x FP 12.4
       mov  @tix_dy,r3
       sra  r3,4
       a    @tix_y,r3                  ; Moved y FP 12.4
*      Position
       mov  r2,r4
       sra  r4,4                       ; Moved x
       mov  r3,r5
       sra  r5,4                       ; Moved y
*      Check moved position for collision
       mov  r4,r0                      ; Moved x
       mov  @tix_y,r1
       sra  r1,4                       ; Unmoved y
       bl   @get_char
       movb r1,r1
       jeq  move_tix_1
*      Collision vertical
       neg  @tix_dx
       jmp  move_tix_3
move_tix_1:
       mov  @tix_x,r0
       sra  r0,4                       ; Unmoved x
       mov  r5,r1                      ; Moved y
       bl   @get_char
       movb r1,r1
       jeq  move_tix_2
*      Collision horizontal
       neg  @tix_dy
       jmp  move_tix_3
*      Move
move_tix_2:
       mov  r2,@tix_x
       mov  r3,@tix_y
move_tix_3:
*      Save current position in the tail list
       mov  @tix_tail_pointer,r0
       ai   r0,-4
       ci   r0,tix_tail
       jhe  move_tix_4
       li   r0,tix_tail+tix_tail_size-4
move_tix_4:
       mov  r0,@tix_tail_pointer
       mov  r5,*r0+                    ; y
       mov  r4,*r0+                    ; x
       .endproc
*// move_tix

*********************************************************************
*
* Upload sprites
*
upload_sprites:
       .proc
       li   r0,spratb
       bl   @vwad
       li   r0,vdpwd
*      Player
       mov  @y,r1
       s    @scroll_y,r1
       ai   r1,-5
       swpb r1
       movb r1,*r0
       mov  @x,r1
       ai   r1,-4
       swpb r1
       mov  r1,*r0
       li   r1,>100d
       movb r1,*r0
       swpb r1
       mov  r1,*r0
*      Tix
       li   r2,4
       mov  @tix_tail_pointer,r3
       li   r4,tix_attr
upload_sprites_1:
       mov  *r3+,r1
       s    @scroll_y,r1
       ai   r1,-9
       ci   r1,-16
       jlt  upload_sprites_2
       ci   r1,191
       jgt  upload_sprites_2
       swpb r1
       movb r1,*r0
       mov  *r3+,r1
       ai   r1,-8
       swpb r1
       movb r1,*r0
       movb *r4+,*r0
       movb *r4+,*r0
       jmp  upload_sprites_3
upload_sprites_2:
       inct r3
       inct r4
upload_sprites_3:
       ai   r3,8
       ci   r3,tix_tail+tix_tail_size
       jl   upload_sprites_4
       ai   r3,-tix_tail_size
upload_sprites_4:
       dec  r2
       jne  upload_sprites_1
*      End marker
       li   r1,>d000
       movb r1,*r0
       .endproc
tix_attr:
       data >000c,>0402,>0803,>0C0e
*// upload_sprites

*********************************************************************
*
* Upload one screen of map to VDP
*
upload_map:
       .proc
       mov  @name_table_flag,r0
       andi r0,>0001
       sla  r0,10
       ai   r0,namet1
       bl   @vwad
       li   r0,map
       li   r1,map+32
       li   r2,768
       clr  r3
       li   r4,vdpwd
       mov  @scroll_y,r5
       dec  r5
       srl  r5,3
       sla  r5,5
       a    r5,r0
       a    r5,r1
       mov  @scroll_y,r5
       dec  r5
       andi r5,7
       sla  r5,4
       swpb r5
       bl   @upload_map_pad
       .endproc
upload_map_1:
       movb *r1+,r3
       sla  r3,2
       socb *r0+,r3
       ab   r5,r3
       movb r3,*r4
       dec  r2
       jne  upload_map_1
       rt
upload_map_2
*// upload_map

*********************************************************************
*
* Fill closure
*
fill_closure:
       .proc
       bl   @save_map
*      Fill to the right
       mov  @x,r0
       mov  @y,r1
       mov  @old_dx,r2
       sla  r2,3
       mov  @old_dy,r3
       sla  r3,3
       s    r2,r0                      ; Backtrack one tile
       s    r3,r1
       s    r3,r0                      ; One tile to the right
       a    r2,r1
       li   r2,blue*256
       li   r3,white*256
       bl   @flood_fill
       mov  r4,r4
       jgt  fill_closure_1
       jeq  fill_closure_1
*      Fill to the left
       bl   @restore_map
       mov  @x,r0
       mov  @y,r1
       mov  @old_dx,r2
       sla  r2,3
       mov  @old_dy,r3
       sla  r3,3
       s    r2,r0                      ; Backtrack one tile
       s    r3,r1
       a    r3,r0                      ; One tile to the left
       s    r2,r1
       li   r2,red*256
       li   r3,white*256
       bl   @flood_fill
fill_closure_1:
       .endproc
*// fill_closure

*********************************************************************
*
* Save map
*
save_map:
       .proc
       li   r0,map
       li   r1,map_backup
       li   r2,map_width*map_height
       bl   @copy
       .endproc
*// save_map

*********************************************************************
*
* Restore map
*
restore_map:
       .proc
       li   r0,map_backup
       li   r1,map
       li   r2,map_width*map_height
       bl   @copy
       .endproc
*// restore_map

*********************************************************************
*
* Get char
*
* r0: x (pixels)
* r1: y (pixels)
*
* On return r1 MSB contains the char and r0 contains the address.
*
get_char:
       .proc
       bl   @map_address
       movb *r0,r1
       .endproc
*// get_char

*********************************************************************
*
* Plot
*
* r0: x (pixels)
* r1: y (pixels)
* r2: char (MSB)
*
* On r0 contains the address. r1 is modified. r2 is preserved.
*
plot:
       .proc
       bl   @map_address
       movb r2,*r0
       .endproc
*// plot

*********************************************************************
*
* Flood fill
*
* r0: x (pixels)
* r1: y (pixels)
* r2 (MSB): replacement char
* r3 (MSB): target char
*
* On return r4 contains the number of pixels filled.
*
flood_fill:
       .proc
       bl   @mark_tix
       bl   @map_address
       bl   @flood_fill_addr
       bl   @unmark_tix
       .endproc
*// flood_fill

*********************************************************************
*
* Flood fill address
*
* r0: map address to fill from
* r2 (MSB): replacement char
* r3 (MSB): target char
*
* On return r4 contains the number of pixels filled.
*
flood_fill_addr:
       li   r1,flood_fill_stack
       mov  r0,*r1+
       clr  r4                         ; Counter
flood_fill_addr_1:
       dect r1
       mov  *r1,r0                     ; Pop address
       movb *r0,r5                     ; Get existing char
       jlt  flood_fill_addr_3          ; Tix found
       cb   r2,r5                      ; Compare to fill char
       jeq  flood_fill_addr_2          ; Stop if filled
       cb   r3,r5                      ; Compare to target char
       jeq  flood_fill_addr_2          ; Stop if filled
       movb r2,*r0+                    ; Fill and move right
       mov  r0,*r1+                    ; Push right
       dect r0                         ; Move left
       mov  r0,*r1+                    ; Push left
       ai   r0,map_width+1             ; Move down
       mov  r0,*r1+                    ; Push down
       ai   r0,-map_width*2            ; Move up
       mov  r0,*r1+                    ; Push up
       inc  r4
       jmp  flood_fill_addr_1
flood_fill_addr_2:
       ci   r1,flood_fill_stack        ; Is stack empty?
       jne  flood_fill_addr_1          ; No - loop
       jmp  flood_fill_addr_4
flood_fill_addr_3:
       seto r4                         ; Tix found
flood_fill_addr_4:
       rt
*// flood_fill_addr

*********************************************************************
*
* Mark tix on map
*
mark_tix:
       .proc
       .push r0
       .push r1
       mov  @tix_x,r0
       srl  r0,4
       mov  @tix_y,r1
       srl  r1,4
       bl   @get_char
       mov  r0,@tix_addr
       movb r1,@tix_char
       movb @b_tix,*r0
       .pop r1
       .pop r0
       .endproc
*// mark_tix

*********************************************************************
*
* Unmark tix on map
*
unmark_tix:
       mov  @tix_addr,r0
       movb @tix_char,*r0
       rt
*// unmark_tix

*********************************************************************
*
* Map address
*
* r0: x (pixels)
* r1: y (pixels)
*
* On return r0 contains the address. r1 is modified.
*
map_address:
       sra  r1,3                       ; y / 8
       sla  r1,5                       ; * 32
       srl  r0,3                       ; x / 8
       a    r1,r0                      ; (x / 8) + (y / 8) * 32
       ai   r0,map
       rt
*// map_address

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r0,ptrntb
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
       li   r0,ptrntb+>800
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
       li   r0,ptrntb+>1000
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
       li   r0,colrtb
       li   r1,colors
       li   r2,8*8*16
       bl   @vmbw
       li   r0,sprptb
       li   r1,SPR0
       li   r2,5*32
       bl   @vmbw
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Copy code to PAD
       li   r0,upload_map_1
       li   r1,upload_map_pad
       li   r2,upload_map_2-upload_map_1
one_time_init_1:
       mov  *r0+,*r1+
       dect r2
       jne  one_time_init_1
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte namet1/>400                ; Name table
       byte >9f                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       rt
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       rt
*// vwad

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,*r15                    ; Write byte to VDP RAM
       rt
*// vsbw

*********************************************************************
*
* VDP multiple Byte Write
*
* R0: Write address in VDP RAM
* R1: Starting read address in CPU RAM
* R2: Number of bytes to send
*
vmbw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
vmbw_1:
       movb *r1+,*r0                   ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_1
       rt
*// vmbw

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
* R2: Number of bytes to write to VDP RAM
*
vsmw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
vsmw_1:
       movb r1,*r0                     ; Write byte to VDP RAM
       dec  r2                         ; Byte counter
       jne  vsmw_1
       rt
*// vsmw

*********************************************************************
*
* VDP Set Read Address
*
* R0: Read address in VDP RAM
*
vrad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       rt
*// vrad

*********************************************************************
*
* VDP Single Byte Read
*
* R0:  Read address in VDP RAM
* R1:  MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       nop
       movb @vdprd,r1                  ; Read byte from VDP RAM
       rt
*// vsbr

*********************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM read address
       andi r0,>3fff                   ; Set read/write bits 14 and 15 to read (00)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       li   r0,vdprd
vmbr_1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr_1                     ; Check if finished
       rt
*// vmbr

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source
* r1: destination
* r2: number of bytes
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* Data
*
b_black:
       byte black
b_white:
       byte white
b_blue:
       byte blue
b_red:
       byte red
b_tix:
       byte tix

       copy "chars.a99"
       copy "sprites.a99"

* One extra map row to support scrolling
       DATA >0101,>0101,>0101,>0101    ;
       DATA >0101,>0101,>0101,>0101    ;
       DATA >0101,>0101,>0101,>0101    ;
       DATA >0101,>0101,>0101,>0101    ;
map:
       copy "map-empty.a99"
map_backup:
       bss  map_width*map_height

flood_fill_stack:
       bss  2*768
trail:
       bss  512
tix_tail:
       bss  tix_tail_size

       end main
