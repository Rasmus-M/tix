*********************************************************************
*
* Tix (Qix like)
* For the TI-99/4A home computer
* 16K cartridge version
*
* September 2019
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base
namet1 equ  >2800                      ; Name table base A
namet2 equ  >2c00                      ; Name table base B
spratb equ  >3000                      ; Sprite attribute table base

**
* Constants
*
n_lives:
       equ  3
map_width:
       equ  32
map_width_pixels:
       equ  map_width*8
map_height:
       equ  40
map_height_pixels:
       equ  map_height*8
map_size:
       equ map_width*map_height
inner_map_size:
       equ (map_width-2)*(map_height-2)
black:
       equ  0
white:
       equ  1
blue:
       equ  2
red:
       equ  3
tix:
       equ  >ff
tix_tail_size:
       equ  128
top_height:
       equ  24
middle_y:
       equ  (192-top_height)/2
sprite_patters:
       equ  16
char_patterns:
       equ  4
font_patterns:
       equ  119
flood_fill_stack_size:
       equ  512
chr_space:
       equ  128
chr_zero:
       equ  144
chr_zero_tall:
       equ  204

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>20                  ; Start of pad variables

**
* PAD variables
*
lives:
       equ  padvar+2
status:
       equ  lives+2
score_lsw:
       equ  status+2
score_msw:
       equ  score_lsw+2
old_score:
       equ  score_msw+2
area:
       equ  old_score+2
old_area:
       equ  area+2
area_required:
       equ  old_area+2
area_percent:
       equ  area_required+2
area_required_percent:
       equ  area_percent+2
time:
       equ  area_required_percent+2
displayed_time:
       equ  time+2
time_out:
       equ  displayed_time+2
level:
       equ  time_out+2
y:
       equ  level+2
x:
       equ  y+2
vy:
       equ  x+2
vx:
       equ  vy+2
dy:
       equ  vx+2
dx:
       equ  dy+2
y_old:
       equ  dx+2
x_old:
       equ  y_old+2
dy_old:
       equ  x_old+2
dx_old:
       equ  dy_old+2
last_safe_y:
       equ  dx_old+2
last_safe_x:
       equ  last_safe_y+2
slow:
       equ  last_safe_x+2
char_aligned:
       equ  slow+2
trail_pointer:
       equ  char_aligned+2
inactivity_time:
       equ  trail_pointer+2
scroll_y:
       equ  inactivity_time+2
scroll_enabled:
       equ  scroll_y+2
name_table_flag:
       equ  scroll_enabled+2
vdp_status:
       equ  name_table_flag+2
tix_x:                                 ; FP 12.4
       equ  vdp_status+2
tix_y:                                 ; FP 12.4
       equ  tix_x+2
tix_dx:                                ; FP 8.8
       equ  tix_y+2
tix_dy:                                ; FP 8.8
       equ  tix_dx+2
tix_ax:                                ; FP 8.8
       equ  tix_dy+2
tix_ay:                                ; FP 8.8
       equ  tix_ax+2
tix_tail_pointer:
       equ  tix_ay+2
tix_addr:
       equ  tix_tail_pointer+2
tix_char:
       equ  tix_addr+2
n_sparks:
       equ  tix_char+2
spark_1_y:
       equ  n_sparks+2
spark_1_x:
       equ  spark_1_y+2
spark_1_dy:
       equ  spark_1_x+2
spark_1_dx:
       equ  spark_1_dy+2
spark_2_y:
       equ  spark_1_dx+2
spark_2_x:
       equ  spark_2_y+2
spark_2_dy:
       equ  spark_2_x+2
spark_2_dx:
       equ  spark_2_dy+2
spark_3_y:
       equ  spark_2_dx+2
spark_3_x:
       equ  spark_3_y+2
spark_3_dy:
       equ  spark_3_x+2
spark_3_dx:
       equ  spark_3_dy+2
spark_4_y:
       equ  spark_3_dx+2
spark_4_x:
       equ  spark_4_y+2
spark_4_dy:
       equ  spark_4_x+2
spark_4_dx:
       equ  spark_4_dy+2
fuse_y:
       equ  spark_4_dx+2
fuse_x:
       equ  fuse_y+2
fuse_dy:
       equ  fuse_x+2
fuse_dx:
       equ  fuse_dy+2
fuse_trail_pointer:
       equ  fuse_dx+2
fuse_active:
       equ  fuse_trail_pointer+2
upload_map_pad:
       equ  fuse_active+2
buffer:
       equ  upload_map_pad+18
pad_max:
       equ  buffer+16

**
* Macros
*
       .defm proc
       mov  r11,*r10+
       .endm

       .defm endproc
       dect r10
       mov  *r10,r11
       b    *r11
       .endm

       .defm push
       mov  #1,*r10+
       .endm

       .defm pop
       dect r10
       mov  *r10,#1
       .endm

       .defm peek
       mov  @-2(r10),#1
       .endm

***************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @one_time_init
new_game:
       bl   @intro
       bl   @init_game
new_level:
       bl   @init_level
new_life:
       bl   @resume_level
       bl   @join_effect
       bl   @game_loop
       mov  @status,r0
       jlt  die
       bl   @level_completed
       jmp  new_level
die:
       bl   @died
       mov  @lives,r0
       jne  new_life
*      Game over
       bl   @game_over
       jmp  new_game
*// main

*********************************************************************
*
* Init game
*
init_game:
       .proc
       seto @scroll_enabled
       clr  @name_table_flag
       li   r0,n_lives
       mov  r0,@lives
       clr  @score_lsw
       clr  @score_msw
       seto @old_score
       clr  @level
       .endproc
*// init_game

*********************************************************************
*
* Init level
*
init_level:
       .proc
       clr  @scroll_y
       clr  @area
       seto @old_area
       li   r0,3*inner_map_size/4
       mov  r0,@area_required
       clr  @time
       clr  @displayed_time
       clr  @trail_pointer
*      Player
       li   r0,132
       mov  r0,@x
       li   r0,4
       mov  r0,@y
*      Tix
       li   r0,196
       li   r1,132
       bl   @init_tix
*      Screen
       bl   @init_map
       .endproc
*// init_level

*********************************************************************
*
* Init Tix
*
* r0: Tix x
* r1: Tix y
*
init_tix:
       mov  r0,r4
       sla  r4,4
       mov  r1,r5
       sla  r5,4
       li   r0,tix_tail
       mov  r0,@tix_tail_pointer
       clr  @tix_ax
       clr  @tix_ay
       li   r0,1*256
       mov  r0,@tix_dx
       li   r1,-1*256
       mov  r1,@tix_dy
       li   r2,tix_tail_size/4
       li   r3,tix_tail
       mov  r4,@tix_x
       mov  r5,@tix_y
init_tix_1:
       mov  r5,*r3+
       mov  r4,*r3+
       dec  r2
       jne  init_tix_1
       rt
*// init_tix

*********************************************************************
*
* Resume level
*
resume_level:
       .proc
       clr  @status
       clr  @fuse_trail_pointer
       clr  @fuse_active
       clr  @inactivity_time
*      Check for trail
       mov  @trail_pointer,r0
       jeq  resume_level_2
*      Move player to start of trail
       mov  @last_safe_x,@x
       mov  @last_safe_y,@y
*      Remove trail
resume_level_1:
       dect r0
       mov  *r0,r1
       movb @b_black,*r1
       ci   r0,trail
       jhe  resume_level_1
       clr  @trail_pointer
resume_level_2:
*      Sparks
       li   r0,init_sparks_data
       bl   @init_sparks
*      Screen
       bl   @refresh_screen
       .endproc
*// resume_level

*********************************************************************
*
* Init sparks
*
init_sparks:
       .proc
       li   r1,spark_1_y
       li   r2,32
       bl   @copy
       li   r0,2
       mov  r0,@n_sparks
       .endproc
init_sparks_data:
       data (map_height_pixels/2)+4,4,1,0
       data (map_height_pixels/2)+4,map_width_pixels-4,-1,0
       data 4,(map_width_pixels/2)+4,0,-1
       data map_height_pixels-4,(map_width_pixels/2)+4,0,1
*// init_sparks

*********************************************************************
*
* Game loop
*
game_loop:
       .proc
game_loop_1:
       bl   @vsync
       bl   @set_vdp_regs
       bl   @check_alignment
       bl   @user_input
       bl   @move_player
       bl   @plot_trail
       bl   @move_tix
       bl   @update_sparks
       bl   @update_fuse
       bl   @upload_sprites
       bl   @upload_map
       bl   @display_score
       bl   @display_area
       bl   @display_time
       bl   @snd_player
       inc  @time
       mov  @status,r0
       jeq  game_loop_1
       .endproc
*// game_loop

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,@vdp_status
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,@vdp_status
       rt
*// vsync

***************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*      Set name table
       mov  @name_table_flag,r0
       andi r0,>0001
       ori  r0,>020a
       bl   @vwtr
       inv  @name_table_flag
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Check aligment to 8 pixel grid
*
check_alignment:
       mov  @x,r0
       andi r0,7
       ci   r0,4
       jne  check_alignment_1
       mov  @y,r1
       andi r1,7
       ci   r1,4
       jne  check_alignment_1
       seto @char_aligned
       jmp  check_alignment_2
check_alignment_1:
       clr  @char_aligned
check_alignment_2:
       rt
*// check_alignment

*********************************************************************
*
* Read user input
*
user_input:
       .proc
       mov  @char_aligned,r0
       jeq  user_input_9
       clr  r2                         ; dx
       clr  r3                         ; dy
       clr  r4                         ; Fire
       li   r0,JOY_FI
       bl   @check_key
*      Fire
       jeq  user_input_1
       seto r4
       clr  @slow
user_input_1:
*      Left
       tb   1
       jeq  user_input_2
       li   r2,-1
       jmp  user_input_5
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       li   r2,1
       jmp  user_input_5
user_input_3:
*      Down
       tb   3
       jeq  user_input_4
       li   r3,1
       jmp  user_input_5
user_input_4:
*      Up
       tb   4
       jeq  user_input_5
       li   r3,-1
user_input_5:
       mov  r2,r0
       jne  user_input_6
       mov  r3,r0
       jeq  user_input_7
user_input_6:
       mov  @dx,@dx_old
       mov  @dy,@dy_old
user_input_7:
       mov  r2,@dx
       mov  r3,@dy
       abs  r4
       jeq  user_input_8
       sla  r2,1
       sla  r3,1
user_input_8:
       mov  r2,@vx
       mov  r3,@vy
user_input_9:
       .endproc
*// user_input

*********************************************************************
*
* Move player
*
move_player:
       .proc
       mov  @x,@x_old
       mov  @y,@y_old
*      Check where we're going
       abs  @char_aligned
       jeq  move_player_4
*      Calculate dx*8 and dy*8
       mov  @dx,r0
       sla  r0,3
       mov  r0,r2                      ; dx * 8
       mov  @dy,r1
       sla  r1,3
       mov  r1,r3                      ; dy * 8
       mov  r2,r2
       jne  move_player_0
       mov  r3,r3
       jeq  move_player_13
*      Check one char away
move_player_0:
       a    @x,r0
       a    @y,r1
       bl   @map_address
       movb *r0,r1
       jeq  move_player_1
       cb   r1,@b_white
       jne  move_player_10
       bl   @check_for_trail
       jeq  move_player_10
       jmp  move_player_4
*      Check two chars away
move_player_1:
       mov  r2,r0
       sla  r0,1
       a    @x,r0
       mov  r3,r1
       sla  r1,1
       a    @y,r1
       bl   @map_address
       cb   *r0,@b_white
       jne  move_player_2
       bl   @check_for_trail
       jeq  move_player_10
*      Check right
move_player_2:
       mov  r2,r0                      ; dx
       a    @x,r0                      ; x + dx
       s    r3,r0                      ; x + dx - dy
       mov  r3,r1                      ; dy
       a    @y,r1                      ; y + dy
       a    r2,r1                      ; y + dy + dx
       bl   @map_address
       cb   *r0,@b_white
       jeq  move_player_10
*      Check left
move_player_3:
       mov  r2,r0                      ; dx
       a    @x,r0                      ; x + dx
       a    r3,r0                      ; x + dx + dy
       mov  r3,r1                      ; dy
       a    @y,r1                      ; y + dy
       s    r2,r1                      ; y + dy - dx
       bl   @map_address
       cb   *r0,@b_white
       jeq  move_player_10
*      Move x
move_player_4:
       mov  @x,r0
       a    @vx,r0
       ci   r0,4
       jlt  move_player_5
       ci   r0,256-4
       jgt  move_player_5
       mov  r0,@x
*      Move y
move_player_5:
       mov  @y,r0
       a    @vy,r0
       ci   r0,4
       jlt  move_player_6
       ci   r0,map_height_pixels-4
       jgt  move_player_6
       mov  r0,@y
*      Scroll
move_player_6:
       abs  @scroll_enabled
       jeq  move_player_10
       mov  @y,r0
       ci   r0,middle_y
       jhe  move_player_7
       clr  r0
       jmp  move_player_9
move_player_7:
       ci   r0,map_height_pixels-middle_y
       jlt  move_player_8
       li   r0,map_height_pixels-(192-top_height)
       jmp  move_player_9
move_player_8:
       mov  @y,r0
       ai   r0,-middle_y
move_player_9:
       mov  r0,@scroll_y
*      Inactivity
move_player_10:
       c    @x,@x_old
       jne  move_player_11
       c    @y,@y_old
       jne  move_player_11
move_player_13:
       inc  @inactivity_time
       jmp  move_player_12
move_player_11:
       clr  @inactivity_time
move_player_12:
       .endproc
*// move_player

*********************************************************************
*
* Plot trail
*
plot_trail:
       .proc
       abs  @char_aligned
       jeq  plot_trail_5
       mov  @x,r0
       mov  @y,r1
       bl   @map_address
       movb *r0,r1
       jne  plot_trail_1
*      Empty position
       mov  @trail_pointer,r1
       jne  plot_trail_0
       li   r1,trail                   ; New trail
       seto @slow
plot_trail_0:
       mov  r0,*r1+
       mov  r1,@trail_pointer
       li   r2,>0100
       movb r2,*r0                     ; Plot
       jmp  plot_trail_5
*      Not empty position
plot_trail_1:
       mov  @trail_pointer,r1
       jeq  plot_trail_4               ; No trail
       dect r1
       c    r0,*r1
       jeq  plot_trail_5
*      End of trail:
       bl   @fill_area
       a    r0,@area
       c    @area,@area_required
       jlt  plot_trail_2
       inc  @status
plot_trail_2:
       abs  @slow
       jeq  plot_trail_3
       sla  r0,1
plot_trail_3:
       bl   @add_score
       clr  @trail_pointer
       clr  @fuse_trail_pointer
       clr  @fuse_active
       jmp  plot_trail_5
plot_trail_4:
       mov  @x_old,@last_safe_x
       mov  @y_old,@last_safe_y
plot_trail_5:
       .endproc
*// plot_trail

*********************************************************************
*
* Move Tix
*
move_tix:
       .proc
*      Check if trailing
       mov  @trail_pointer,r0
       jeq  move_tix_1
*      Move towards player
       mov  @x,r0
       sla  r0,4
       s    @tix_x,r0
       sra  r0,7
       mov  r0,@tix_ax
       mov  @y,r1
       sla  r1,4
       s    @tix_y,r1
       sra  r1,7
       mov  r1,@tix_ay
       jmp  move_tix_3
*      Just move
move_tix_1:
       clr  @tix_ax
       clr  @tix_ay
       mov  @tix_dx,r0
       abs  r0
       ci   r0,>0200
       jlt  move_tix_2
       mov  @tix_dx,r0
       sra  r0,1
       mov  r0,@tix_dx
move_tix_2:
       mov  @tix_dy,r1
       abs  r1
       ci   r1,>0200
       jlt  move_tix_3
       mov  @tix_dy,r1
       sra  r1,1
       mov  r1,@tix_dy
*      Acceleration
move_tix_3:
       a    @tix_ax,@tix_dx            ; dx FP 8.8
       a    @tix_ay,@tix_dy            ; dy FP 8.8
*      Velocity
       mov  @tix_dx,r2
       sra  r2,4
       a    @tix_x,r2                  ; Moved x FP 12.4
       mov  @tix_dy,r3
       sra  r3,4
       a    @tix_y,r3                  ; Moved y FP 12.4
*      Position
       mov  r2,r4
       sra  r4,4                       ; Moved x
       mov  r3,r5
       sra  r5,4                       ; Moved y
*      Check moved position for collision
       mov  r4,r0                      ; Moved x
       mov  @tix_y,r1
       sra  r1,4                       ; Unmoved y
       bl   @map_address
       movb *r0,r1
       jeq  move_tix_4
*      Collision vertical
       neg  @tix_dx
       jmp  move_tix_5
move_tix_4:
       mov  @tix_x,r0
       sra  r0,4                       ; Unmoved x
       mov  r5,r1                      ; Moved y
       bl   @map_address
       movb *r0,r1
       jeq  move_tix_6
*      Collision horizontal
       neg  @tix_dy
move_tix_5:
*      Check if hit trail
       bl   @check_for_trail
       jne  move_tix_7
*      Hit trail
       dec  @status
       jmp  move_tix_7
*      Move
move_tix_6:
       mov  r2,@tix_x
       mov  r3,@tix_y
move_tix_7:
*      Save current position in the tail list
       mov  @tix_tail_pointer,r0
       ai   r0,-4
       ci   r0,tix_tail
       jhe  move_tix_8
       li   r0,tix_tail+tix_tail_size-4
move_tix_8:
       mov  r0,@tix_tail_pointer
       mov  r5,*r0+                    ; y
       mov  r4,*r0+                    ; x
       .endproc
*// move_tix

*********************************************************************
*
* Update sparks
*
update_sparks:
       .proc
       mov  @n_sparks,r2
       li   r3,spark_1_y               ; Ptr y
       mov  r3,r4                      ; Ptr y
       ai   r4,4                       ; Ptr dy
update_sparks_1:
       mov  r3,r5                      ; Copy ptr y
       mov  r4,r6                      ; Copy ptr dy
*      Check if aligned
       mov  *r3+,r1                    ; y
       andi r1,7
       ci   r1,4
       jne  update_sparks_1a
       mov  *r3+,r0                    ; x
       andi r0,7
       ci   r0,4
       jeq  update_sparks_1b
update_sparks_1a:
       b    @update_sparks_14
*      Turn towards player
update_sparks_1b:
       li   r12,white*256
update_sparks_2:
       mov  r5,r3                      ; Ptr y
       mov  *r3+,r1                    ; y
       mov  *r3+,r0                    ; x
       bl   @map_address
       mov  r0,r7                      ; Save map address
       mov  r5,r3                      ; Ptr y
       mov  *r4,r1                     ; dy
       jne  update_sparks_7
*      Moving in x, check if we can move up/down
       clr  r0                         ; dx = 0
       mov  @y,r1                      ; Player y
       s    *r3,r1                     ; Player y - y
       jlt  update_sparks_4
*      Try down
       mov  *r3,r8                     ; y
       ci   r8,map_height_pixels-5
       jgt  update_sparks_6            ; Not if y > 315
       ai   r7,map_width
       cb   *r7,r12                    ; Check if white
       jne  update_sparks_3
       li   r1,1
       jmp  update_sparks_11a
*      Try up instead
update_sparks_3:
       mov  *r3,r8                     ; y
       ci   r8,5
       jlt  update_sparks_6            ; Not if y < 5
       ai   r7,-2*map_width
       cb   *r7,r12                    ; Check if white
       jne  update_sparks_6
       li   r1,-1
       jmp  update_sparks_11a
*      Try up
update_sparks_4:
       mov  *r3,r8                     ; y
       ci   r8,5
       jlt  update_sparks_6            ; Not if y < 5
       ai   r7,-map_width
       cb   *r7,r12                    ; Check if white
       jne  update_sparks_5
       li   r1,-1
       jmp  update_sparks_11a
*      Try down instead
update_sparks_5:
       mov  *r3,r8                     ; y
       ci   r8,map_height_pixels-5
       jgt  update_sparks_6            ; Not if y > 315
       ai   r7,2*map_width
       cb   *r7,r12                    ; Check if white
       jne  update_sparks_6
       li   r1,1
       jmp  update_sparks_11a
update_sparks_6:
       clr  r1
       jmp  update_sparks_12
*      Moving in y, check if we can move left/right
update_sparks_7:
       clr  r1                         ; dy = 0
       inct r3
       mov  @x,r0                      ; Player x
       s    *r3,r0                     ; PLayer x - x
       jlt  update_sparks_9
*      Try right
       mov  *r3,r8                     ; x
       ci   r8,map_width_pixels-5
       jgt  update_sparks_11           ; Not if x > 251
       inc  r7
       cb   *r7,r12                    ; Check if white
       jne  update_sparks_8
       li   r0,1
       jmp  update_sparks_11a
*      Try left instead
update_sparks_8:
       mov  *r3,r8                     ; x
       ci   r8,5
       jlt  update_sparks_11           ; Not if x < 5
       dect r7
       cb   *r7,r12                    ; Check if white
       jne  update_sparks_11
       li   r0,-1
       jmp  update_sparks_11a
*      Try left
update_sparks_9:
       mov  *r3,r8                     ; x
       ci   r8,5
       jlt  update_sparks_11           ; Not if x < 5
       dec  r7
       cb   *r7,r12                    ; Check if white
       jne  update_sparks_10
       li   r0,-1
       jmp  update_sparks_11a
*      Try right instead
update_sparks_10:
       mov  *r3,r8                     ; x
       ci   r8,map_width_pixels-5
       jgt  update_sparks_11           ; Not if x > 251
       inct r7
       cb   *r7,r12                    ; Check if white
       jne  update_sparks_11
       li   r0,1
       jmp  update_sparks_11a
update_sparks_11:
       clr  r0
       jmp  update_sparks_12
*      Check that spark is not moving into trail
update_sparks_11a:
       mov  @trail_pointer,r9
       jeq  update_sparks_13
       c    r7,@trail
       jne  update_sparks_13
*      Check if it's OK to continue moving
update_sparks_12:
       mov  r5,r3                      ; Ptr y
       mov  r6,r4                      ; Ptr dy
       mov  *r4+,r1                    ; dy
       sla  r1,3                       ; dy * 8
       a    *r3+,r1                    ; dy * 8 + y
       mov  *r4+,r0                    ; dx
       sla  r0,3                       ; dx * 8
       a    *r3+,r0                    ; dx * 8 + x
       bl   @map_address
       cb   *r0,@b_white
       jeq  update_sparks_14            ; Move
       clr  r0
       clr  r1
*      Save dy and dx
update_sparks_13:
       mov  r6,r4
       mov  r1,*r4+                    ; Save dy
       mov  r0,*r4+                    ; Save dx
*      Move
update_sparks_14:
       mov  r5,r3
       mov  r6,r4
       a    *r4+,*r3+                  ; y = y + dy
       a    *r4+,*r3+                  ; x = x + dx
*      Check if player is captured
       mov  r5,r3
       mov  *r3+,r0
       s    @y,r0
       abs  r0
       ci   r0,4
       jgt  update_sparks_15
       mov  *r3+,r0
       s    @x,r0
       abs  r0
       ci   r0,4
       jgt  update_sparks_15
*      Captured
       li   r0,init_sparks_data
       mov  r5,r3
       mov  *r0+,*r3+
       mov  *r0+,*r3+
       mov  *r0+,*r3+
       mov  *r0+,*r3+
       dec  @status
*      Loop
update_sparks_15:
       mov  r5,r3
       ai   r3,8
       ai   r4,4
       dec  r2
       jeq  update_sparks_16
       b    @update_sparks_1
update_sparks_16:
*      Create more sparks
       abs  @time_out
       jeq  update_sparks_17
       clr  @time_out
       mov  @n_sparks,r0
       ci   r0,4
       jeq  update_sparks_17
       inc  @n_sparks
update_sparks_17:
       .endproc
*// update_sparks

*********************************************************************
*
* Update fuse
*
update_fuse:
       .proc
       mov  @trail_pointer,r0
       jeq  update_fuse_6
       abs  @fuse_active
       jne  update_fuse_2
       mov  @inactivity_time,r0
       ci   r0,30
       jlt  update_fuse_6
*      Start/restart fuse
       mov  @fuse_trail_pointer,r4
       jne  update_fuse_1
*      Start fuse
       li   r4,trail
       mov  *r4+,r0
       mov  r4,@fuse_trail_pointer
       bl   @map_coords
       mov  r0,@fuse_x
       mov  r1,@fuse_y
*      Restart fuse
update_fuse_1:
       seto @fuse_active
       jmp  update_fuse_4
*      Fuse active
update_fuse_2:
       mov  @inactivity_time,r0
       jeq  update_fuse_3
       mov  @fuse_trail_pointer,r4
       jmp  update_fuse_4
*      Deactivate fuse
update_fuse_3:
       clr  @fuse_active
       jmp  update_fuse_6
*      Check if aligned
update_fuse_4:
       mov  @fuse_x,r0
       andi r0,7
       ci   r0,4
       jne  update_fuse_5
       mov  @fuse_y,r1
       andi r1,7
       ci   r1,4
       jne  update_fuse_5
*      Set new direction
       mov  *r4+,r0
       mov  r4,@fuse_trail_pointer
       bl   @map_coords
       s    @fuse_x,r0
       sra  r0,3
       mov  r0,@fuse_dx
       s    @fuse_y,r1
       sra  r1,3
       mov  r1,@fuse_dy
update_fuse_5:
*      Move fuse
       a    @fuse_dx,@fuse_x
       a    @fuse_dy,@fuse_y
*      Check if player is captured
       c    @fuse_x,@x
       jne  update_fuse_6
       c    @fuse_y,@y
       jne  update_fuse_6
*      Stop fuse
       dec  @status
       clr  @fuse_active
       clr  @fuse_trail_pointer
update_fuse_6:
       .endproc
*// update_fuse

*********************************************************************
*
* Upload sprites
*
upload_sprites:
       .proc
       li   r0,spratb
       bl   @vwad
*      Player
       li   r3,y
       li   r4,>000d
       bl   @upload_sprite
*      Tix
       li   r2,4
       mov  @tix_tail_pointer,r3
       jeq  upload_sprites_4a
       li   r4,tix_attr
upload_sprites_1:
       mov  *r3+,r1
       s    @scroll_y,r1
       jlt  upload_sprites_2
       ai   r1,top_height-9
       ci   r1,191
       jgt  upload_sprites_2
       swpb r1
       movb r1,*r15
       mov  *r3+,r1
       ai   r1,-8
       swpb r1
       movb r1,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       jmp  upload_sprites_3
upload_sprites_2:
       inct r3
       inct r4
upload_sprites_3:
       ai   r3,8
       ci   r3,tix_tail+tix_tail_size
       jl   upload_sprites_4
       ai   r3,-tix_tail_size
upload_sprites_4:
       dec  r2
       jne  upload_sprites_1
*      Sparks
upload_sprites_4a:
       li   r3,spark_1_y
       li   r4,>200b
       mov  @n_sparks,r5
       jeq  upload_sprites_6
upload_sprites_5:
       bl   @upload_sprite
       ai   r3,4                       ; Skip dy/dx
       dec  r5
       jne  upload_sprites_5
*      Fuse
       abs  @fuse_active
       jeq  upload_sprites_6
       li   r3,fuse_y
       li   r4,>3008
       bl   @upload_sprite
*      End marker
upload_sprites_6:
       movb @b_d0,*r15
       .endproc
tix_attr:
       data >100c,>1402,>1803,>1C0e
*// upload_sprites

*********************************************************************
*
* Upload sprite
*
* r3: points to y
* r4: contains base pattern and color
*
upload_sprite:
       mov  *r3+,r1                    ; y
       s    @scroll_y,r1
       jlt  upload_sprite_2
       ci   r1,(192-top_height)+8
       jhe  upload_sprite_2
       ai   r1,top_height-9
       swpb r1
       movb r1,*r15
       mov  r4,r2                      ; Pattern and color
       mov  *r3+,r1                    ; x
       ai   r1,-8
       jgt  upload_sprite_1
       ai   r1,32                      ; EC
       ori  r2,>0080
upload_sprite_1:
       swpb r1
       mov  r1,*r15
       mov  @time,r1                  ; Animation frame
       andi r1,>000c
       swpb r1                         ; Pattern
       soc  r2,r1
       movb r1,*r15
       swpb r1                         ; Color
       mov  r1,*r15
       jmp  upload_sprite_3
upload_sprite_2:
       inct r3
upload_sprite_3:
       rt
*// upload_sprite

*********************************************************************
*
* Upload sprite simple
*
* r3: points to y
* r4: contains base pattern and color
*
upload_sprite_simple:
       mov  *r3+,r1                    ; y
       s    @scroll_y,r1
       ai   r1,top_height
       ci   r1,-8
       jlt  upload_sprite_simple_2
       ci   r1,192+8
       jhe  upload_sprite_simple_2
       mov  *r3+,r0                    ; x
       ci   r0,-8
       jlt  upload_sprite_simple_3
       ci   r0,256+8
       jhe  upload_sprite_simple_3
       ci   r0,8
       jgt  upload_sprite_simple_1
       ai   r0,32                      ; EC
       ori  r4,>0080
upload_sprite_simple_1:
       ai   r1,-9
       movb @r1lb,*r15
       ai   r0,-8
       movb @r0lb,*r15
       movb r4,*r15                    ; Pattern
       movb @r4lb,*r15                 ; Color
       jmp  upload_sprite_simple_3
upload_sprite_simple_2:
       inct r3
upload_sprite_simple_3:
       rt
*// upload_sprite_simple

*********************************************************************
*
* Upload one screen of map to VDP
*
upload_map:
       .proc
       mov  @name_table_flag,r0
       andi r0,>0001
       sla  r0,10
       ai   r0,namet1+(32*top_height/8)
       bl   @vwad
       li   r0,map
       li   r1,map+32
       li   r2,32*(192-top_height)/8
       clr  r3
       mov  @scroll_y,r5
       dec  r5
       srl  r5,3
       sla  r5,5
       a    r5,r0
       a    r5,r1
       mov  @scroll_y,r5
       dec  r5
       andi r5,7
       sla  r5,4
       movb @r5lb,r5
       li   r6,r3lb
       bl   @upload_map_pad
       .endproc
upload_map_1:
       mov  *r1+,r3                    ; Get 2 bytes from row 1
       sla  r3,2                       ; Shift up
       soc  *r0+,r3                    ; Combine with two bytes from row 2
       a    r5,r3                      ; Add scroll offset
       movb r3,*r15                     ; Send one byte to VDP
       movb *r6,*r15                    ; Send the other byte to VDP
       dect r2                         ; Counter
       jne  upload_map_1               ; Loop
       rt
upload_map_2
*// upload_map

*********************************************************************
*
* Display score
*
display_score:
       .proc
       c    @score_lsw,@old_score
       jeq  display_score_1
       mov  @score_msw,r0
       mov  @score_lsw,r1
       div  @d10000,r0
       mov  r1,r8
       mov  r0,r1
       li   r0,24
       li   r2,2
       bl   @display_tall_decimal
       mov  r8,r1
       li   r0,26
       li   r2,4
       bl   @display_tall_decimal
       mov  @score_lsw,@old_score
display_score_1:
       .endproc
*// display_score

*********************************************************************
*
* Display area
*
display_area:
       .proc
       c    @area,@old_area
       jeq  display_area_1
       mov  @area,r0
       mpy  @d10,r0                    ; r1=area*10, r0=0
       li   r2,inner_map_size/10
       div  r2,r0                      ; area*10/(total_area/10)=100*area/total_area
       mov  r0,@area_percent
       mov  r0,r1
       li   r0,44
       li   r2,2
       bl   @display_decimal
       mov  @area,@old_area
display_area_1:
       .endproc
*// display_area

*********************************************************************
*
* Display time
*
* When @displayed_time=16, the full line is displayed.
* When @displayed_time=0, no line is displayed.
*
display_time:
       .proc
       mov  @time,r0
       andi r0,>003f
       jne  display_time_3
*      Set displayed time
       mov  @displayed_time,r0
       jeq  display_time_1
       dec  r0
       jmp  display_time_2
display_time_1:
       li   r0,16
display_time_2:
       mov  r0,@displayed_time
*      Display
       li   r0,namet1+64
       bl   @display_time_line
       li   r0,namet2+64
       bl   @display_time_line
display_time_3:
       .endproc
display_time_line:
       .proc
       mov   @displayed_time,r3
       ci   r3,16
       jeq  display_time_line_1
*      Remove one character of the line
       mov  r0,r4
       li   r5,16
       a    r3,r5
       a    r5,r0
       ci   r5,31
       jne  display_time_line_4
       mov  @lives,r7
       ci   r7,1
       jne  display_time_line_4
       inc  r5
display_time_line_4:
       bl   @vwad
       movb @no_time_line(r5),*r15
       mov  r4,r0
       li   r5,15
       s    r3,r5
       a    r5,r0
       bl   @vwad
       movb @no_time_line(r5),*r15
       jmp  display_time_line_3
*      Redraw the full line
display_time_line_1:
       li   r1,top+64
       li   r2,31
       bl   @vmbw
       mov  @lives,r0
       ci   r0,1
       jne  display_time_line_2
       inc  r1
display_time_line_2:
       movb *r1,*r15
       mov  @time,r0
       jeq  display_time_line_3
       seto @time_out
display_time_line_3:
       .endproc
*// display_time

*********************************************************************
*
* Level completed
*
level_completed:
       .proc
*      Refresh screen
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
       bl   @refresh_screen
*      Pause
       li   r2,120
       bl   @wait
*      Display result
       li   r0,3*32
       li   r1,32
       li   r2,21
       bl   @display_box
       li   r0,texts_result
       bl   @display_texts
*      Area claimed
       li   r0,9*32+21
       mov  @area_percent,r1
       li   r2,2
       bl   @display_decimal
*      Area required
       li   r0,11*32+21
       mov  @area_required_percent,r1
       li   r2,2
       bl   @display_decimal
*      Bonus
       li   r0,13*32+15
       mov  @area_percent,r1
       s    @area_required_percent,r1
       li   r2,2
       bl   @display_decimal
*      Bonus points
       mov  @area_percent,r0
       s    @area_required_percent,r0
       mpy  @d1000,r0
       mov  r1,r0
       bl   @add_score
       li   r2,5
       li   r0,15*32+14
       bl   @display_decimal
       bl   @display_score
*      Pause
       li   r2,120
       bl   @wait
*      Next level
       inc  @level
       .endproc
*// level_completed

*********************************************************************
*
* Player died
*
died:
       .proc
       dec  @lives
       bl   @display_lives
       bl   @split_effect
       li   r2,60
       bl   @wait
       .endproc
*// died

*********************************************************************
*
* Game over
*
game_over:
       .proc
       li   r0,10*32+11
       li   r1,11
       li   r2,3
       bl   @display_box
       li   r0,11*32+12
       li   r1,txt_game_over
       bl   @display_text
       li   r2,120
       bl   @wait
       .endproc
*// game_over

*********************************************************************
*
* Fill area
*
* On return r0 contains the number of tiles filled, incuding outline
*
fill_area:
       .proc
       bl   @save_map
       abs  @slow
       jne  fill_area_1
       li   r9,blue*256
       jmp  fill_area_2
fill_area_1:
       li   r9,red*256
fill_area_2:
*      Fill to the right
       mov  @x,r0
       mov  @y,r1
       mov  @dx_old,r2
       mov  @dy_old,r3
       sla  r2,3
       sla  r3,3
       s    r2,r0                      ; Backtrack one tile
       s    r3,r1
       s    r3,r0                      ; One tile to the right
       a    r2,r1
       mov  r9,r2
       li   r3,white*256
       bl   @flood_fill
       mov  r4,r4
       jgt  fill_area_3
       jeq  fill_area_3
*      Fill to the left
       bl   @restore_map
       mov  @x,r0
       mov  @y,r1
       mov  @dx_old,r2
       sla  r2,3
       mov  @dy_old,r3
       sla  r3,3
       s    r2,r0                      ; Backtrack one tile
       s    r3,r1
       a    r3,r0                      ; One tile to the left
       s    r2,r1
       mov  r9,r2
       li   r3,white*256
       bl   @flood_fill
fill_area_3:
       mov  @trail_pointer,r0
       ai   r0,-trail
       srl  r0,1
       a    r4,r0
       .endproc
*// fill_area

*********************************************************************
*
* Init map
*
init_map:
       li   r3,map_height
init_map_with_height:
       .proc
       li   r0,map
       li   r2,map_size
       bl   @clear
       li   r0,white*256
       dect r3
*      Top
       li   r1,map
       li   r2,map_width
init_map_1:
       movb r0,*r1+
       dec  r2
       jne  init_map_1
*      Right
       li   r1,map+map_width+(map_width-1)
       mov  r3,r2
init_map_2:
       movb r0,*r1
       ai   r1,map_width
       dec  r2
       jne  init_map_2
*      Left
       li   r1,map+map_width
       mov  r3,r2
init_map_3:
       movb r0,*r1
       ai   r1,map_width
       dec  r2
       jne  init_map_3
*      Bottom
       li   r2,map_width
init_map_4:
       movb r0,*r1+
       dec  r2
       jne  init_map_4
       .endproc
*// init_map

*********************************************************************
*
* Refresh screen
*
refresh_screen:
       .proc
       bl   @display_score
       bl   @display_area
       bl   @display_area_required
       bl   @display_time
       bl   @display_lives
       bl   @upload_map
       bl   @vsync
       bl   @set_vdp_regs
       bl   @upload_map
       bl   @vsync
       bl   @set_vdp_regs
       .endproc
*// refresh_map

*********************************************************************
*
* Save map
*
save_map:
       .proc
       li   r0,map
       li   r1,map_backup
       li   r2,map_size
       bl   @copy
       .endproc
*// save_map

*********************************************************************
*
* Restore map
*
restore_map:
       .proc
       li   r0,map_backup
       li   r1,map
       li   r2,map_size
       bl   @copy
       .endproc
*// restore_map

*********************************************************************
*
* Get char
*
* r0: x (pixels)
* r1: y (pixels)
*
* On return r1 MSB contains the char and r0 contains the address.
*
get_char:
       .proc
       bl   @map_address
       movb *r0,r1
       .endproc
*// get_char

*********************************************************************
*
* Plot
*
* r0: x (pixels)
* r1: y (pixels)
* r2: char (MSB)
*
* On r0 contains the address. r1 is modified. r2 is preserved.
*
plot:
       .proc
       bl   @map_address
       movb r2,*r0
       .endproc
*// plot

*********************************************************************
*
* Flood fill
*
* r0: x (pixels)
* r1: y (pixels)
* r2 (MSB): replacement char
* r3 (MSB): target char
*
* On return r4 contains the number of pixels filled.
*
flood_fill:
       .proc
       bl   @mark_tix
       bl   @map_address
       bl   @flood_fill_addr
       bl   @unmark_tix
       .endproc
*// flood_fill

*********************************************************************
*
* Flood fill address
*
* r0: map address to fill from
* r2 (MSB): replacement char
* r3 (MSB): target char
*
* On return r4 contains the number of pixels filled.
*
flood_fill_addr:
       li   r1,flood_fill_stack
       mov  r0,*r1+
       clr  r4                         ; Counter
flood_fill_addr_1:
       dect r1
       mov  *r1,r0                     ; Pop address
       movb *r0,r5                     ; Get existing char
       jlt  flood_fill_addr_3          ; Tix found
       cb   r2,r5                      ; Compare to fill char
       jeq  flood_fill_addr_2          ; Stop if filled
       cb   r3,r5                      ; Compare to target char
       jeq  flood_fill_addr_2          ; Stop if filled
       movb r2,*r0+                    ; Fill and move right
       mov  r0,*r1+                    ; Push right
       dect r0                         ; Move left
       mov  r0,*r1+                    ; Push left
       ai   r0,map_width               ; Move down-left
       mov  r0,*r1+                    ; Push down-left
       inc  r0                         ; Move down-middle
       mov  r0,*r1+                    ; Push down-middle
       inc  r0                         ; Move down-right
       mov  r0,*r1+                    ; Push down-right
       ai   r0,-map_width*2            ; Move up-right
       mov  r0,*r1+                    ; Push up-right
       dec  r0                         ; Move up-middle
       mov  r0,*r1+                    ; Push up-middle
       dec  r0                         ; Move up-left
       mov  r0,*r1+                    ; Push up-left
       inc  r4
       jmp  flood_fill_addr_1
flood_fill_addr_2:
       ci   r1,flood_fill_stack        ; Is stack empty?
       jne  flood_fill_addr_1          ; No - loop
       jmp  flood_fill_addr_4
flood_fill_addr_3:
       seto r4                         ; Tix found
flood_fill_addr_4:
       rt
*// flood_fill_addr

*********************************************************************
*
* Check if map address is part of trail
*
* r0: Map address
*
* On return eq is set if address is part of trail.
*
check_for_trail:
       mov  @trail_pointer,r1
       jeq  check_for_trail_2
check_for_trail_1:
       dect r1
       c    r0,*r1
       jeq  check_for_trail_3
       ci   r1,trail
       jne  check_for_trail_1
check_for_trail_2:
       c    r0,r1                       ; Set neq: r0 is map address; r1 is 0 or trail
check_for_trail_3:
       rt

*********************************************************************
*
* Mark tix on map
*
mark_tix:
       .proc
       .push r0
       .push r1
       mov  @tix_x,r0
       srl  r0,4
       mov  @tix_y,r1
       srl  r1,4
       bl   @get_char
       mov  r0,@tix_addr
       movb r1,@tix_char
       movb @b_tix,*r0
       .pop r1
       .pop r0
       .endproc
*// mark_tix

*********************************************************************
*
* Unmark tix on map
*
unmark_tix:
       mov  @tix_addr,r0
       movb @tix_char,*r0
       rt
*// unmark_tix

*********************************************************************
*
* Map address from coordinates
*
* r0: x (pixels)
* r1: y (pixels)
*
* On return r0 contains the address. r1 is modified.
*
map_address:
       sra  r1,3                       ; y / 8
       sla  r1,5                       ; * 32
       srl  r0,3                       ; x / 8
       a    r1,r0                      ; (x / 8) + (y / 8) * 32
       ai   r0,map
       rt
*// map_address

*********************************************************************
*
* Add to score
*
* r0: Points to add
*
add_score:
       a    r0,@score_lsw
       jnc  add_score_1
       inc  @score_msw
add_score_1:
       rt
*// add_score

*********************************************************************
*
* Map coordinates from address
*
* r0: address
*
* On return r0 contains the x coord and r1 contains the y coord
* of the center of the tile.
*
map_coords:
       ai   r0,-map                    ; Offset
       mov  r0,r1                      ; copy offset
       andi r0,31                      ; x = offset mod 32
       sla  r0,3                       ; * 8
       ai   r0,4                       ; + 4
       srl  r1,5                       ; y = offset / 32
       sla  r1,3                       ; * 8
       ai   r1,4                       , + 4
       rt
*// map_coords

*********************************************************************
*
* Display area required
*
display_area_required:
       .proc
       mov  @area_required,r0
       mpy  @d10,r0                    ; r1=area*10, r0=0
       li   r2,inner_map_size/10
       div  r2,r0                      ; area*10/(total_area/10)=100*area/total_area
       mov  r0,@area_required_percent
       mov  r0,r1
       li   r0,48
       li   r2,2
       bl   @display_decimal
       .endproc
*// display_area_required

*********************************************************************
*
* Display lives
*
display_lives:
       .proc
       li   r0,namet1+31
       bl   @display_lives_1
       li   r0,namet2+31
       bl   @display_lives_1
       .endproc
display_lives_1:
       .proc
       mov   @lives,r3
       sla  r3,2
       ai   r3,lives_0
       movb *r3+,r1
       bl   @vsbw
       ai   r0,32
       movb *r3+,r1
       bl   @vsbw
       ai   r0,32
       mov  @displayed_time,r2
       ci   r2,16
       jeq  display_lives_2
       inc  r3
display_lives_2:
       movb *r3,r1
       bl   @vsbw
       .endproc
lives_0:
       byte >e0,>e1,>e2,>eb
lives_1:
       byte >e0,>e6,>e7,>ec
lives_2:
       byte >e4,>e5,>e2,>eb
lives_3:
       byte >e3,>e1,>e2,>eb
*// display_lives

*********************************************************************
*
* Display double height number
*
* r0: Screen offset
* r1: Number to display
* r2: Number of digits
*
display_tall_decimal:
       .proc
       mov  r0,r5
       mov  r2,r6
       bl   @bin_to_dec
       ai   r5,namet1
       li   r7,2
display_tall_decimal_1:
*      1st name table buffer, 1st row
       mov  r5,r0
       li   r1,buffer
       mov  r6,r2
       li   r3,(chr_zero_tall-chr_zero)*256
       bl   @vmbw_offs
*      1st name table buffer, 2nd row
       mov  r5,r0
       ai   r0,32
       li   r1,buffer
       mov  r6,r2
       li   r3,(chr_zero_tall+10-chr_zero)*256
       bl   @vmbw_offs
*      Next buffer
       ai   r5,namet2-namet1
       dec  r7
       jne  display_tall_decimal_1
       .endproc
*// display_tall_decimal

*********************************************************************
*
* Display decimal number
*
* r0: Screen offset
* r1: Number to display
* r2: Number of digits
*
display_decimal:
       .proc
       mov  r0,r5
       mov  r2,r6
       bl   @bin_to_dec
*      1st name table buffer
       mov  r5,r0
       ai   r0,namet1
       li   r1,buffer
       mov  r6,r2
       bl   @vmbw
*      2nd name table buffer
       mov  r5,r0
       ai   r0,namet2
       li   r1,buffer
       mov  r6,r2
       bl   @vmbw
       .endproc
*// display_decimal

*********************************************************************
*
* Convert binary number to decimal
*
* r1: Number to display
* r2: Number of digits
*
* On return @buffer contains the number
*
bin_to_dec:
       li   r4,buffer
       li   r3,5
       s    r2,r3
       sla  r3,1
       ai   r3,d10000
       dec  r2
bin_to_dec_1:
       clr  r0
       div  *r3+,r0
       ai   r0,chr_zero
       swpb r0
       movb r0,*r4+
       dec  r2
       jne  bin_to_dec_1
       ai   r1,chr_zero
       swpb r1
       movb r1,*r4+
       rt
*// bin_to_dec

*********************************************************************
*
* Display texts
*
* r0: Points to list of strings to display (list of offset, string pointer)
* terminated by -1.
*
display_texts:
       .proc
       mov  r0,r5
display_texts_1:
       mov  *r5+,r0
       jlt  display_texts_2
       mov  *r5+,r1
       bl   @display_text
       jmp  display_texts_1
display_texts_2:
       .endproc
*// display_texts

*********************************************************************
*
* Display text
*
* r0: Screen offset
* r1: String to display (0 terminated)
*
display_text:
       .proc
*      1st name table buffer
       mov  r0,r3
       ai   r0,namet1
       mov  r1,r4
       bl   @vwad
       bl   @display_text_line
*      2nd name table buffer
       mov  r3,r0
       ai   r0,namet2
       mov  r4,r1
       bl   @vwad
       bl   @display_text_line
       .endproc
display_text_line:
       movb *r1+,r2
       jeq  display_text_line_1
       ai   r2,(chr_space-32)*256
       movb r2,*r15
       jmp  display_text_line
display_text_line_1:
       rt
*// display_text

*********************************************************************
*
* Display box
*
* r0: Screen offset
* r1: Width
* r2: Height
*
box_top_left:
       byte >ed
box_top:
       byte >ee
box_top_right:
       byte >ef
box_left:
       byte >f0
box_middle:
       byte chr_space
box_right:
       byte >f1
box_bottom_left:
       byte >f2
box_bottom:
       byte >f3
box_bottom_right:
       byte >f4
       even
display_box:
       .proc
       mov  r0,r4
       mov  r1,r5
       mov  r2,r6
       ai   r0,namet1
       bl   @display_box_1
       mov  r4,r0
       mov  r5,r1
       mov  r6,r2
       ai   r0,namet2
       bl   @display_box_1
       .endproc
display_box_1:
       .proc
*      Top row
       bl   @vwad
       movb @box_top_left,*r15
       dect r1
       mov  r1,r3
display_box_2:
       movb @box_top,*r15
       dec  r3
       jne  display_box_2
       movb @box_top_right,*r15
*      Middle rows
       dect r2
display_box_3:
       ai   r0,32
       bl   @vwad
       movb @box_left,*r15
       mov  r1,r3
display_box_4:
       movb @box_middle,*r15
       dec  r3
       jne  display_box_4
       movb @box_right,*r15
       dec  r2
       jne  display_box_3
*      Bottom row
       ai   r0,32
       bl   @vwad
       movb @box_bottom_left,*r15
       mov  r1,r3
display_box_5:
       movb @box_bottom,*r15
       dec  r3
       jne  display_box_5
       movb @box_bottom_right,*r15
       .endproc
*// display_box

*********************************************************************
*
* Join player effect
*
join_effect:
       .proc
*      Refresh screen
       bl   @vsync
       bl   @set_vdp_regs
*      Initialize sprite positions
       li   r3,buffer
       li   r2,4
       li   r1,join_coords
join_effect_1:
       mov  *r1+,r0
       a    @y,r0
       mov  r0,*r3+
       mov  *r1+,r0
       a    @x,r0
       mov    r0,*r3+
       dec  r2
       jne  join_effect_1
*      Play sound
       bl   @play_join
*      Loop
       li   r0,127
       mov  r0,@time
join_effect_2:
       bl   @vsync
*      Upload sprites
       li   r0,spratb
       bl   @vwad
       li   r3,buffer
       li   r5,4
join_effect_3:
       li   r4,>000d
       bl   @upload_sprite_simple
       dec  r5
       jne  join_effect_3
       movb @b_d0,*r15
*      Move sprites
       li   r2,4
       li   r3,buffer
       li   r5,join_dirs
join_effect_4:
       a    *r5+,*r3+
       a    *r5+,*r3+
*      Next sprite
       dec  r2
       jne  join_effect_4
*      Sound player
       bl   @snd_player
*      Next frame
       dec  @time
       jne  join_effect_2
       .endproc
join_coords:
       data -256,-256,256,-256,256,256,-256,256
join_dirs:
       data 2,2,-2,2,-2,-2,2,-2
*// join_effect

*********************************************************************
*
* Split player effect
*
split_effect:
       .proc
*      Initialize sprite positions
       li   r3,buffer
       li   r2,4
split_effect_1:
       mov  @y,*r3+
       mov  @x,*r3+
       dec  r2
       jne  split_effect_1
*      Play sound
       bl   @play_split
*      Loop
       li   r0,127
       mov  r0,@time
split_effect_2:
       bl   @vsync
*      Upload sprites
       li   r0,spratb
       bl   @vwad
       li   r3,buffer
       li   r5,4
split_effect_3:
       li   r4,>000d
       bl   @upload_sprite_simple
       dec  r5
       jne  split_effect_3
       movb @b_d0,*r15
*      Move sprites
       li   r2,4
       li   r3,buffer
       li   r5,split_dirs
split_effect_4:
       a    *r5+,*r3+
       a    *r5+,*r3+
*      Next sprite
       dec  r2
       jne  split_effect_4
*      Play sound
       bl   @snd_player
*      Next frame
       dec  @time
       jne  split_effect_2
       .endproc
split_dirs:
       data 2,2,-2,2,-2,-2,2,-2
*// split_effect

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       bl   @graphics_mode
*      Patterns
       li   r0,ptrntb
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
       li   r0,ptrntb+>800
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
       li   r0,ptrntb+>1000
       li   r1,chars
       li   r2,8*8*16
       bl   @vmbw
*      Colors
       li   r0,colrtb
       li   r1,colors
       li   r2,8*8*16
       bl   @vmbw
*      Font
       li   r0,ptrntb+>400
       li   r1,PAT128
       li   r2,font_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>c00
       li   r1,PAT128
       li   r2,font_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>1400
       li   r1,PAT128
       li   r2,font_patterns*8
       bl   @vmbw
*      Font colors
       li   r0,colrtb+>400
       li   r1,COL128
       li   r2,font_patterns*8
       bl   @vmbw
*      Sprite patterns
       li   r0,sprptb
       li   r1,SPR0
       li   r2,sprite_patters*32
       bl   @vmbw
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
*      Copy code to PAD
       li   r0,upload_map_1
       li   r1,upload_map_pad
       li   r2,upload_map_2-upload_map_1
one_time_init_1:
       mov  *r0+,*r1+
       dect r2
       jne  one_time_init_1
*      Top panel
       li   r0,namet1
       li   r1,top
       li   r2,top_height/8*32
       bl   @vmbw
       li   r0,namet2
       li   r1,top
       li   r2,top_height/8*32
       bl   @vmbw
*      Variables
       clr  @area
       clr  @score_lsw
       clr  @score_msw
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte namet1/>400                ; Name table
       byte >9f                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       rt
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       rt
*// vwad

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,*r15                    ; Write byte to VDP RAM
       rt
*// vsbw

*********************************************************************
*
* VDP multiple Byte Write
*
* R0: Write address in VDP RAM
* R1: Starting read address in CPU RAM
* R2: Number of bytes to send
*
vmbw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbw_1:
       movb *r1+,*r15                  ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_1
       rt
*// vmbw

*********************************************************************
*
* VDP multiple Byte Write with offset
*
* R0: Write address in VDP RAM
* R1: Starting read address in CPU RAM
* R2: Number of bytes to send
* R3: Offset to add to bytes
*
vmbw_offs:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbw_offs_1:
       movb *r1+,r4
       ab   r3,r4
       movb r4,*r15                    ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_offs_1
       rt
*// vmbw_offs

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
* R2: Number of bytes to write to VDP RAM
*
vsmw:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vsmw_1:
       movb r1,*r15                    ; Write byte to VDP RAM
       dec  r2                         ; Byte counter
       jne  vsmw_1
       rt
*// vsmw

*********************************************************************
*
* VDP Set Read Address
*
* R0: Read address in VDP RAM
*
vrad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       rt
*// vrad

*********************************************************************
*
* VDP Single Byte Read
*
* R0:  Read address in VDP RAM
* R1:  MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM read address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       nop
       movb @vdprd,r1                  ; Read byte from VDP RAM
       rt
*// vsbr

*********************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       movb  @r0lb,@vdpwa              ; Send low byte of VDP RAM read address
       andi r0,>3fff                   ; Set read/write bits 14 and 15 to read (00)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM read address
       li   r0,vdprd
vmbr_1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr_1                     ; Check if finished
       rt
*// vmbr

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source
* r1: destination
* r2: number of bytes
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* Wait
*
* r2: number of frames
*
wait:
       .proc
wait_1:
       bl   @vsync
       dec  r2
       jne  wait_1
       .endproc
*// wait

*********************************************************************
*
* Wait fire
*
* r2: number of frames
*
wait_fire:
       .proc
wait_fire_1:
       bl   @vsync
       li   r0,JOY_FI
       bl   @check_key
       jne  wait_fire_2
       dec  r2
       jne  wait_fire_1
wait_fire_2:
       .endproc
*// wait

*********************************************************************
*
* Program files
*
       copy "intro.a99"
       copy "sound-defs.a99"
       copy "sound-fx.a99"
       copy "sound-player.a99"
       copy "music-player.a99"

*********************************************************************
*
* Data
*
snd_channel_1:
       bss  snd_channel_size
snd_channel_2:
       bss  snd_channel_size
snd_channel_3:
       bss  snd_channel_size
snd_channel_4:
       bss  snd_channel_size
snd_track_1:
       bss  snd_track_size
snd_track_2:
       bss  snd_track_size
snd_track_3:
       bss  snd_track_size
module_speed:
       data 4

texts_result:
       data 9*32+9,txt_percentage
       data 11*32+9,txt_threshold
       data 13*32+9,txt_bonus
       data -1

txt_game_over:
       text "GAME OVER"
       byte 0
txt_percentage:
       text "PERCENTAGE: 00%"
       byte 0
txt_threshold:
       text "THRESHOLD:  75%"
       byte 0
txt_bonus:
       text "BONUS 00 X 1000"
       byte 0
       even

d10000:
       data 10000
d1000:
       data 1000
d100:
       data 100
d10:
       data 10
b_black:
       byte black
b_white:
       byte white
b_blue:
       byte blue
b_red:
       byte red
b_tix:
       byte tix
b_d0:
       byte >d0

       copy "chars.a99"
       copy "sprites.a99"
       copy "font.a99"
top:
       copy "top.a99"
       data >E700                      ; Last character with white tix

* 3rd top row without red time line
no_time_line:
       DATA >80E8,>E9E9,>E9E9,>EA80    ;
       DATA >8080,>8080,>8080,>8080    ;
       DATA >8080,>8080,>8080,>8080    ;
       DATA >8080,>8080,>8080,>80EB    ;
       DATA >EC00                      ; Last character with white tix

* One extra map row to support scrolling
       DATA >0101,>0101,>0101,>0101    ;
       DATA >0101,>0101,>0101,>0101    ;
       DATA >0101,>0101,>0101,>0101    ;
       DATA >0101,>0101,>0101,>0101    ;
map:
       bss  map_size
map_backup:
       bss  map_size
tix_tail:
       bss  tix_tail_size
trail:
       equ  $
flood_fill_stack:
       bss  flood_fill_stack_size

       end main
